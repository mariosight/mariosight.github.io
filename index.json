[{"content":"参考文献 Go语言动手写Web框架 - Gee第二天 上下文Context | 极客兔兔\n大佬写的非常清晰易懂，跟着走下来对整个web框架的了解变得更加深入了，也整理了一些学习心得\n整体架构 简单介绍一下整体框架的设计思路以及对应需要实现的一些功能，框架的具体实现主要是根据极客兔兔的博客以及极客时间的教学视频进行的 Web框架主要是用于解决标准库中需要频繁处理的问题或者将处理起来较为麻烦的部分进行一定程度上的封装 根据HTTP基础部分整体的框架其实很清楚了，用户这边写的是路由和对应的处理方法，框架用HandlerFunc来接受对应的handler，与对应的路由通过map进行绑定，通过不同的请求可以映射到不同的处理方法 首先要有一个整体代表服务器的抽象，Server，提供生命周期控制、路由注册接口，作为http包到Web框架的桥梁，怎么接入http包？通过http包暴露的一个接口handler来作为Web框架与http包的连接点，其次是对于路由的处理，这也是Web框架的核心之一，通过动态路由将请求映射到函数，还有一些功能如上下文，分组控制，中间件等等。\n功能简介 动态路由：对于路由来说，最重要的当然是注册与匹配了。开发服务时，注册路由规则，映射handler；访问时，匹配路由规则，查找到对应的handler。因此，Trie树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前part的节点，则新建一个。 上下文：将Handler的参数变成Context，设计上下文(Context)，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，提供对 JSON、HTML 等返回类型的支持。 分组控制：分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。\n以/post开头的路由匿名可访问。 以/admin开头的路由需要鉴权。 以/api开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。 中间件：中间件(middlewares)，就是非业务的技术类组件。Web框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自己定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样。\n插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂。如果插入点离用户太近，那和用户直接定义一组函数，每次在 Handler 中手工调用没有多大的优势了。 中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。 HTML模板：HTML模板（template）部分主要是实现两个内容：\n实现静态资源服务(Static Resource) 支持HTML模板渲染 将静态文件放在/web，filepath的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。 返回文件直接交给http.FileServer处理就好了 Go语言内置了html/template为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。 错误处理：用户不正确的参数，可能会触发某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的，所以错误处理机制是非常必要的，将错误处理作为一个中间件添加到框架中，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。\nHttp库下方法的使用 这一部分主要是介绍一下net/http库下的一些基础功能使用，Body的获取，URL的查询，Form表单的输出等等\nhttp.ResponseWriter: 这是一个接口，提供了对 HTTP 响应的返回方法。你可以使用它来写入 HTTP 响应的头信息和主体内容。 *http.Request: 这是一个指向 http.Request 的指针，表示 HTTP 请求。它包含了关于 HTTP 请求的所有信息，如请求方法、URL、头信息、表单数据等 Body和GetBody 1func home(w http.ResponseWriter, r *http.Request) { 2 //body 只能读取一次 3 body, err := io.ReadAll(r.Body) 4 if err != nil { 5 fmt.Println(w, \u0026#34;读取请求体失败\u0026#34;) 6 return 7 } 8 fmt.Fprintln(w, \u0026#34;第一次请求：\u0026#34;, string(body), \u0026#34;长度为\u0026#34;, len(string(body))) 9 //尝试再次读取，不会报错，但是什么也没有读到 10 body, err = io.ReadAll(r.Body) 11 if err != nil { 12 fmt.Println(w, \u0026#34;读取请求体失败\u0026#34;) 13 return 14 } 15 fmt.Fprintln(w, \u0026#34;第二次请求：\u0026#34;, string(body), \u0026#34;长度为\u0026#34;, len(string(body))) 16 if r.GetBody == nil { 17 fmt.Fprintln(w, \u0026#34;GetBody为空\u0026#34;) 18 } else { 19 fmt.Fprintln(w, \u0026#34;GetBody不为空\u0026#34;) 20 } 21} URL 1func query(w http.ResponseWriter, r *http.Request) { 2 //查询参数是一个map，type Values map[string][]string 3 values := r.URL.Query() 4 //url.Values类型是一个映射字符串到字符串切片的映射，通常用于处理URL查询参数 5 fmt.Fprintln(w, reflect.TypeOf(values)) 6 name := values.Get(\u0026#34;name\u0026#34;) 7 fmt.Fprintln(w, \u0026#34;查询对应的值为\u0026#34;, name) 8} 9 10func wholeUrl(w http.ResponseWriter, r *http.Request) { 11 data, _ := json.Marshal(r.URL) 12 fmt.Fprintln(w, string(data)) 13} Form 1func form(w http.ResponseWriter, r *http.Request) { 2 //直接输出表单,没有对应输出 3 fmt.Fprintln(w, r.Form) 4 //需要先解析表单，才会有对应输出 5 r.ParseForm() 6 fmt.Fprintln(w, r.Form) 7} Server实现 Httpserver 是HTTP服务器的封装，实现了Server接口，提供路由注册，生命周期控制以及作为与http包结合的桥梁 ServerHTTP是整个Web框架的核心入口，在其中将实现大部分功能，Context构建，路由匹配以及业务逻辑的执行 封装与抽象：将HTTP请求的处理、响应的生成、路由的注册等逻辑都通过封装类和接口进行抽象，Context封装了请求和响应对象，HandlerBaseOnMap封装了路由逻辑，sdkHttpserver封装了服务器的启动和路由配置。\n1// Server 定义一个服务器接口 2type Server interface { 3 Routable 4 Start(address string) error 5 GET(pattern string, handlerFunc func(c *Context)) 6 POST(pattern string, handlerFunc func(c *Context)) 7} 8type Httpserver struct { 9 Name string 10 handler *Router 11} 12 13func NewHttpServer(name string) Server { 14 return \u0026amp;Httpserver{ 15 Name: name, 16 handler: NewRouter(), 17 } 18} 19func (s *Httpserver) Route(method string, pattern string, handlerFunc HandlerFunc) { 20 s.handler.Route(method, pattern, handlerFunc) 21} 22func (s *Httpserver) GET(pattern string, handlerFunc func(c *Context)) { 23 s.handler.Route(\u0026#34;GET\u0026#34;, pattern, handlerFunc) 24} 25func (s *Httpserver) POST(pattern string, handlerFunc func(c *Context)) { 26 s.handler.Route(\u0026#34;POST\u0026#34;, pattern, handlerFunc) 27} 28func (s *Httpserver) Start(address string) error { 29 //http.Handle(\u0026#34;/\u0026#34;, s) 30 //net.Listen函数创建一个监听器，监听器监听的是TCP网络地址 31 //l, err := net.Listen(\u0026#34;tcp\u0026#34;, address) 32 //if err != nil { // return err //} 33 //http.serve 启动的灵活性更强 34 //return http.Serve(l, s) 35 36 //ListenAndServe监听TCP网络地址addr，并为该网络地址的网络连接提供HTTP服务。 37 return http.ListenAndServe(address, s) 38} 39func (s *Httpserver) ServeHTTP(W http.ResponseWriter, R *http.Request) { 40 c := NewContext(W, R) 41 s.handler.handle(c) 42} 实现Handler接口 Go通过接口实现多态，Go的接口是隐式的，只要结构体上定义的“方法”在形式上（名称、参数、返回值）和 接口定义的“方法”一样，那么这个结构体就自动实现了这个接口，我们就可以使用这个接口变量来指向这个结构体对象，实际上也就是多态和继承。 Handler是一个接口，需要实现方法 ServeHTTP ，也就是说，只要传入任何实现了 ServerHTTP 接口的实例，所有的HTTP请求，都交给了该实例进行处理，ServeHTTP 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。 如何设计方法ServeHTTP，这个方法有2个参数，第二个参数是 Request ，该对象包含了该HTTP请求的所有的信息，比如请求地址、Header和Body等信息；第一个参数是 ResponseWriter ，利用 ResponseWriter 可以构造针对该请求的响应\n1// HandlerFunc 定义使用的请求处理程序 2type HandlerFunc func(c *Context) 3 4// 确保Httpserver实现了Server接口 5var _ Server = \u0026amp;Httpserver{} 6 7// Server 定义一个服务器接口 8type Server interface { 9 AddRoute(method string, pattern string, handlerFunc HandlerFunc) 10 Start(address string) error 11 GET(pattern string, handlerFunc HandlerFunc) 12 POST(pattern string, handlerFunc HandlerFunc) 13 NewGroup(prefix string) *RouterGroup 14 Use(middlewares ...HandlerFunc) 15} 16 17type Httpserver struct { 18 Name string 19 handler *Router 20 *RouterGroup 21 Groups []*RouterGroup 22} 23 24func NewHttpServer(name string) Server { 25 server := \u0026amp;Httpserver{ 26 Name: name, 27 handler: NewRouter(), 28 } 29 //初始化 RouterGroup，将其与server关联 30 server.RouterGroup = \u0026amp;RouterGroup{server: server} 31 // 将该 RouterGroup 添加到 server 的 groups 列表中 32 server.Groups = []*RouterGroup{server.RouterGroup} 33 return server 34} 35 36func (s *Httpserver) ServeHTTP(W http.ResponseWriter, R *http.Request) { 37 //当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过URL的前缀来判断。得到中间件列表后，赋值给c.handlers 38 var middlewares []HandlerFunc 39 for _, group := range s.Groups { 40 if strings.HasPrefix(R.URL.Path, group.prefix) { 41 middlewares = append(middlewares, group.middlewares...) 42 } 43 } 44 c := NewContext(W, R) 45 c.handlers = middlewares 46 s.handler.handle(c) 47} 上下文定义 Context随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由Context承载。因此，设计Context结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用Context实例，Context就像一次会话的百宝箱，可以找到任何东西 我大致明白对应的意思了，实际上就是不需要自己去写对应的读取请求解析请求，而是转交给对应的框架来实现，而这部分框架就是用Context来实现的，用来简化传输的部分\n1type Context struct { 2 R *http.Request 3 W http.ResponseWriter 4} 5 6// ReadJson 读取json数据 7func (c *Context) ReadJson(resp interface{}) error { 8 body, err := io.ReadAll(c.R.Body) 9 if err != nil { 10 return err 11 } 12 err = json.Unmarshal(body, resp) 13 if err != nil { 14 return err 15 } 16 return nil 17} 18 19// WriteJson 写入json数据 20func (c *Context) WriteJson(code int, resp interface{}) error { 21 c.W.WriteHeader(code) 22 data, err := json.Marshal(resp) 23 if err != nil { 24 return err 25 } 26 _, err = c.W.Write(data) 27 if err != nil { 28 return err 29 } 30 return nil 31} 32func (c *Context) OkJson(resp interface{}) error { 33 return c.WriteJson(http.StatusOK, resp) 34} 35func (c *Context) BadRequestJson(resp interface{}) error { 36 return c.WriteJson(http.StatusBadRequest, resp) 37} 路由实现 静态路由（Map实现） 使用map定义一个handler，用来实现路由功能，允许根据HTTP方法和URL路径将请求分发到相应的处理函数 使用map来存储对应的函数，key是method与pattern的组合，将所有方法存储在哈希表中，然后通过key去匹配\n1type Handler interface { 2 http.Handler 3 Routable 4} 5//http.Handler的实现，直接继承过来 6type Handler interface { 7 ServeHTTP(ResponseWriter, *Request) 8} 创建一个实例用来进行我们自己的处理逻辑\n1type HandlerBaseOnMap struct { 2 handlers map[string]func(c *Context) 3} 整体的Handler部分\n1type Routable interface { 2 Route(method string, pattern string, handlerFunc func(c *Context)) 3} 4 5// 基于map的路由 6type Handler interface { 7 http.Handler 8 Routable 9} 10type HandlerBaseOnMap struct { 11 handlers map[string]func(c *Context) 12} 13 14func (h *HandlerBaseOnMap) Route(method string, pattern string, handlerFunc func(c *Context)) { 15 key := h.key(method, pattern) 16 h.handlers[key] = handlerFunc 17} 18 19func (h *HandlerBaseOnMap) ServeHTTP(writer http.ResponseWriter, request *http.Request) { 20 key := h.key(request.Method, request.URL.Path) 21 if handler, ok := h.handlers[key]; ok { 22 handler(NewContext(writer, request)) 23 } else { 24 writer.WriteHeader(http.StatusNotFound) 25 } 26} 27 28func (h *HandlerBaseOnMap) key(method string, pattern string) string { 29 return method + \u0026#34;#\u0026#34; + pattern 30} 31func NewHandlerBasedOnMap() Handler { 32 return \u0026amp;HandlerBaseOnMap{ 33 handlers: make(map[string]func(c *Context)), 34 } 35} 动态路由（Trie树实现） 之前用了一个非常简单的map结构存储了路由表，使用map存储键值对，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。那如果我们想支持类似于/hello/:name这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而非某一条固定的路由。例如/hello/:name，可以匹配/hello/geektutu、hello/jack等。 实现的动态路由主要具备两个功能：\n参数匹配:。例如 /p/:lang/doc，可以匹配 /p/c/doc 和 /p/go/doc。 通配*。例如 /static/*filepath，可以匹配/static/fav.ico，也可以匹配/static/js/jQuery.js，这种模式常用于静态服务器，能够递归地匹配子路径 实现动态路由最常用的数据结构，被称为前缀树(Trie树)：每一个节点的所有的子节点都拥有相同的前缀。 介绍一下前缀树的概念： 前缀树本身是一个多叉树结构，树中的每个节点存储一个字符，它与普通树状数据结构最大的差异在于，存储数据的 key 不存放于单个节点中，而是由从根节点 root 出发直到来到目标节点target node之间的沿途路径组成. 基于这样的构造方式，导致拥有相同前缀的字符串可以复用公共的父节点，直到在首次出现不同字符的位置才出现节点分叉，最终形成多叉树状结构. 比如以下面search、see、seat为例，从根节点出发，先存储se，然后进行分叉，分出a和e，接着继续分叉分出r和t 当存储拥有公共前缀的内容时，可以在很大程度上节省空间提高节点利用率. 同时由于这种公共前缀的设计方式，也赋以了Trie树能够支持前缀频率统计以及前缀模糊匹配的功能 分组控制 这里实现的分组控制也是以前缀来区分，并且支持分组的嵌套。例如/post是一个分组，/post/a和/post/b可以是该分组下的子分组。作用在/post分组上的中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。中间件可以给框架提供无限的扩展能力，应用在分组上，可以使得分组控制的收益更为明显，而不是共享相同的路由前缀这么简单。例如/admin的分组，可以应用鉴权中间件；/分组应用日志中间件。 首先是一开始结构体的定义\n1//server作为顶层的分层，要在server里添加RouterGroup 2type Httpserver struct { 3 Name string 4 handler *Router 5 *RouterGroup 6 Groups []*RouterGroup 7} 8 9//在Group中，保存一个指针，指向server 10type RouterGroup struct { 11 prefix string //所有该组中的路由都将共享这个前缀 12 middlewares []HandlerFunc //支持中间件 13 parent *RouterGroup //支持嵌套 14 server *Httpserver //所有组共享一个server实例 15} 16 17func NewHttpServer(name string) Server { 18 server := \u0026amp;Httpserver{ 19 Name: name, 20 handler: NewRouter(), 21 } 22 //初始化 RouterGroup，将其与server关联 23 server.RouterGroup = \u0026amp;RouterGroup{server: server} 24 // 将该 RouterGroup 添加到 server 的 groups 列表中 25 server.Groups = []*RouterGroup{server.RouterGroup} 26 return server 27} Group的构造函数，用来构造RouterGroup\n1// NewGroup 以创建新的 RouterGroup 2// 所有组共享同一个 server 实例 3func (g *RouterGroup) NewGroup(prefix string) *RouterGroup { 4 server := g.server 5 //创建一个新的Group 6 newGroup := \u0026amp;RouterGroup{ 7 prefix: g.prefix + prefix, // 新组的前缀是父组前缀加上新前缀 8 parent: g, 9 server: server, //所有组共享同一个 server 实例 10 } 11 server.Groups = append(server.Groups, newGroup) 12 return newGroup 13} 后面就是将路由相关的函数都通过RouterGroup来实现\n1//将和路由有关的函数，都交给RouterGroup实现 2func (g *RouterGroup) AddRoute(method string, pattern string, handlerFunc HandlerFunc) { 3 //将路由组的前缀（g.prefix）和当前路由的模式（pattern）拼接在一起，形成完整的路由路径 4 pattern = g.prefix + pattern 5 //日志输出，非常直观 6 log.Printf(\u0026#34;Route %4s - %s\u0026#34;, method, pattern) 7 g.server.handler.AddRoute(method, pattern, handlerFunc) 8} 9func (g *RouterGroup) GET(pattern string, handlerFunc HandlerFunc) { 10 g.AddRoute(http.MethodGet, pattern, handlerFunc) 11} 12 13func (g *RouterGroup) POST(pattern string, handlerFunc HandlerFunc) { 14 g.AddRoute(http.MethodPost, pattern, handlerFunc) 15} 然后是在主函数里面进行分组\n1 v1 := server.NewGroup(\u0026#34;/v1\u0026#34;) 2 { 3 v1.GET(\u0026#34;/hello\u0026#34;, Hello) 4 v1.GET(\u0026#34;/signup\u0026#34;, Signup) 5 } 6 v2 := server.NewGroup(\u0026#34;/v2\u0026#34;) 7 { 8 v2.GET(\u0026#34;/hello/:name\u0026#34;, Param) 9 v2.POST(\u0026#34;/login\u0026#34;, Login) 10 } 中间件 中间件的定义与路由映射的Handler一致，处理的输入是Context对象。插入点是框架接收到请求初始化Context对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对Context进行二次加工。另外通过调用(*Context).Next()函数，中间件可等待用户自己定义的Handler处理结束后，再做一些额外的操作，例如计算本次处理所用时间等。即所实现的中间件支持用户在请求被处理的前后，做一些额外的操作。 之前的框架设计是这样的，当接收到请求后，匹配路由，该请求的所有信息都保存在Context中，中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在Context中，依次进行调用。\n1// Logger 当在中间件中调用Next方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在Next方法之后定义的部分 2func Logger() HandlerFunc { 3\treturn func(c *Context) { 4\t// 开始计时 5\tt := time.Now() 6\t// 处理请求 7\tc.Next() 8\t// 计算处理时间 9\tlog.Printf(\u0026#34;[%d] %s in %v\u0026#34;, c.StatusCode, c.Req.RequestURI, time.Since(t)) 10\t} 11} HTML模板渲染 处理静态文件\n1// createStaticHandler 静态文件的处理程序 2func (g *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc { 3 absolutePath := path.Join(g.prefix, relativePath) 4 fileServer := http.StripPrefix(absolutePath, http.FileServer(fs)) 5 return func(c *Context) { 6 file := c.Param(\u0026#34;filepath\u0026#34;) 7 // 检查文件是否存在 8 if _, err := fs.Open(file); err != nil { 9 c.Status(http.StatusNotFound) 10 return 11 } 12 fileServer.ServeHTTP(c.W, c.R) 13 } 14} 15 16// Static 提供静态文件 17// 用户可以将磁盘上的某个文件夹root映射到路由relativePath 18func (g *RouterGroup) Static(relativePath string, root string) { 19 handler := g.createStaticHandler(relativePath, http.Dir(root)) 20 urlPattern := path.Join(relativePath, \u0026#34;/*filepath\u0026#34;) 21 g.GET(urlPattern, handler) 22} HTML模板渲染\n1Engine struct { 2\t*RouterGroup 3\trouter *router 4\tgroups []*RouterGroup // store all groups 5\thtmlTemplates *template.Template // for html render 6\tfuncMap template.FuncMap // for html render 7} 8 9func (engine *Engine) SetFuncMap(funcMap template.FuncMap) { 10\tengine.funcMap = funcMap 11} 12 13func (s *Httpserver) LoadHTMLGlob(pattern string) { 14 //因为运行配置里写的工作目录是LearnGo，修改一下变成LearnGo\\web就可以了 15 s.htmlTemplates = template.Must(template.New(\u0026#34;\u0026#34;).Funcs(s.funcMap).ParseGlob(pattern)) 16} 错误处理 使用error与panic用来进行错误处理，error一般用于表达可以被处理的错误，panic一般用于表达非常严重不能恢复的错误，遇事不决选error errors包下的方法：New创建一个新的error，Is判断是不是特定的某个error，As类型转换为特定的error，Unwrap解除包装，返回被包装的error\n1func ErrorsPkg() { 2 err := \u0026amp;MyError{} 3 //返回的是一个包装好的error 4 wrappedErr := fmt.Errorf(\u0026#34;this is an wrapped error %w\u0026#34;, err) 5 //再解出来 6 if errors.Is(err, errors.Unwrap(wrappedErr)) { 7 fmt.Println(\u0026#34;unwrapped\u0026#34;) 8 } 9 //判断是否是包装好的error 10 if errors.Is(wrappedErr, err) { 11 fmt.Println(\u0026#34;wrapped is err\u0026#34;) 12 } 13 copyErr := \u0026amp;MyError{} 14 //尝试将wrappedErr转换成为MyError 15 if errors.As(wrappedErr, \u0026amp;copyErr) { 16 fmt.Println(\u0026#34;convert error\u0026#34;) 17 } 18} 延迟（defer）从下往上执行，先进后出，类似于栈\n1defer func() { 2 fmt.Println(\u0026#34;aaa\u0026#34;) 3}() 4defer func() { 5 fmt.Println(\u0026#34;bbb\u0026#34;) 6}() 7defer func() { 8 fmt.Println(\u0026#34;ccc\u0026#34;) 9}() 错误处理也可以作为一个中间件，增强整体框架的能力\n1func Recovery() HandlerFunc { 2\treturn func(c *Context) { 3\tdefer func() { 4\tif err := recover(); err != nil { 5\tmessage := fmt.Sprintf(\u0026#34;%s\u0026#34;, err) 6\tlog.Printf(\u0026#34;%s\\n\\n\u0026#34;, trace(message)) 7\tc.String(http.StatusInternalServerError, \u0026#34;Internal Server Error\u0026#34;) 8\t} 9\t}() 10 11\tc.Next() 12\t} 13} ","permalink":"https://mariosight.github.io/posts/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AAweb%E6%A1%86%E6%9E%B6/","summary":"\u003ch4 id=\"参考文献\"\u003e参考文献\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"https://geektutu.com/post/gee-day2.html\"\u003eGo语言动手写Web框架 - Gee第二天 上下文Context | 极客兔兔\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e大佬写的非常清晰易懂，跟着走下来对整个web框架的了解变得更加深入了，也整理了一些学习心得\u003c/p\u003e","title":"Go语言之构造一个Web框架"},{"content":"ndnSIM 搭建以及使用 安装准备 1sudo apt install build-essential libsqlite3-dev libboost-all-dev libssl-dev git python-setuptools castxml 2sudo apt install python-dev python-pygraphviz python-kiwi python-gnome2 ipython libcairo2-dev python3-gilibgirepository1.0-dev python-gi python-gi-cairo gir1.2-gtk-3.0 gir1.2-goocanvas-2.0 python-pip 3pip install pygraphviz pycairo PyGObject pygccxml 4sudo apt-get install graphviz libgraphviz-dev graphviz-dev pkg-config 5pip install pygraphviz 下载源码 现在任意文件创建个 ndnsim 文件夹\n1mkdir ndnSIM2.7 然后进入该文件夹下，进行源码的下载\n1cd ndnSIM2.7 2git clone https://github.com/named-data-ndnSIM/ns-3-dev.git ns-3 3git clone https://github.com/named-data-ndnSIM/pybindgen.git pybindgen 4git clone https://github.com/named-data-ndnSIM/ndnSIM.git ns-3/src/ndnSIM 修改对应版本号 这里的命令依靠 git 实现，能到这一步肯定都安装好了，就不多说了\n首先进入到 ndnSIM 的核心源码地带\n1cd ns-3/src/ndnSIM 通过 git checkout 修改版本号\n1git checkout ndnSIM-2.7 也可以通过 git tag 查看所有的版本号，然后修改为想要安装的版本\n然后安装 NFD 和 ndn-cxx 模块\n1git submodule update --init 接下来进入到 ndnSIM2.7/ns-3 文件下进行版本的修改\n1git checkout ndnSIM-ns-3.29 接下对 pybindgen 的版本进行修改\n1cd ndnSIM2.7/pybindgen 2git checkout 0.19.0 然后在此目录下安装安装该 python 模块\n1sudo python setup.py install 可视化出现问题 1PyViz visualizer : not enabled (Python Bindings are needed but not enabled) 2Python Bindings : not enabled (PyBindGen missing) 这个问题其实很好解决，执行一下\n1pip install pybindgen 注:以下代码若不知道存放路径,运行 pip show pybindgen 即可，或者重新运行一遍上面的代码\n1./waf -d debug configure --with-pybindgen=存放路径//ex：./waf -d debug configure --with-pybindgen=/home/antl417/anaconda3/lib/python3.8/site-packages 1#在此虚拟机中应该是下面的 2./waf -d debug configure --with-pybindgen=/home/yin/.local/lib/python3.8/site-packages 然后执行\n1./waf configure --with-pybindgen=/home/yin/.local/lib/python3.8/site-packages --enable-examples 2./waf 3./waf --run ndn-simple --vis 正常情况直接编译完成，出现错误的话请看下面的修改提示\n进入到可视化模块下将‘file=’删除\n1cd ndnSIM2.7/ns-3/src/visualizer/visualizer 进入 base.py 文件，修改保存即可 成功编译： 第二种错误可能出现在运行时加上–vis 可视化模块时，如下图所示 这种情况下，还是进入刚才的那个文件夹，修改 hub.py 文件\n将 from.import 注释，修改为 import core，再次运行就可以了\n第三个错误也可能是出现在加上-vis 的情况，如下图所示： 安装 gi.cairo 即可解决：\n1sudo apt-get install gi.cairo 成功启动 然后执行\n1./waf configure --with-pybindgen=/home/yin/.local/lib/python3.8/site-packages --enable-examples 2./waf 3./waf --run ndn-simple --vis 启动之后的 simple 如下图所示： 参考教程 使用教程：ndnSIM 的使用教程-CSDN 博客\n安装流程：在 Ubuntu 安装 ndnSIM_ndnsim20 安装教程-CSDN 博客\n可视化出现问题解决方法：NS3 可视化问题及解决办法_ns3.34 python binding-CSDN 博客\n","permalink":"https://mariosight.github.io/posts/ndnsim%E4%BB%BF%E7%9C%9F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/","summary":"\u003ch3 id=\"ndnsim-搭建以及使用\"\u003endnSIM 搭建以及使用\u003c/h3\u003e\n\u003ch5 id=\"安装准备\"\u003e安装准备\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo apt install build-essential libsqlite3-dev libboost-all-dev libssl-dev git python-setuptools castxml\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo apt install python-dev python-pygraphviz python-kiwi python-gnome2 ipython libcairo2-dev python3-gilibgirepository1.0-dev python-gi python-gi-cairo gir1.2-gtk-3.0 gir1.2-goocanvas-2.0 python-pip\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003epip install pygraphviz pycairo PyGObject pygccxml\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo apt-get install graphviz libgraphviz-dev graphviz-dev pkg-config\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003epip install pygraphviz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch5 id=\"下载源码\"\u003e下载源码\u003c/h5\u003e\n\u003cp\u003e现在任意文件创建个 ndnsim 文件夹\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003emkdir ndnSIM2.7\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后进入该文件夹下，进行源码的下载\u003c/p\u003e","title":"ndnSIM仿真安装以及使用"},{"content":"My First Post 这是第一篇文章\n","permalink":"https://mariosight.github.io/posts/first-post/","summary":"\u003ch2 id=\"my-first-post\"\u003eMy First Post\u003c/h2\u003e\n\u003cp\u003e这是第一篇文章\u003c/p\u003e","title":"First Post"},{"content":"Ubuntu22.04LTS 下Python3.7.9+Charm-Crypto+pypbc+Jupyter环境搭建 参考文献 Linux安装Charm-crypto环境详细流程_android使用charm-crypto-CSDN博客\n1 前置工具 为了方便本地操作，先安装openssh-server和net-tools 1sudo apt install openssh-server net-tools -y 连接到本地xshell以后，再进行如下安装 1sudo apt install gcc g++ make vim vsftpd wget m4 flex bison python3-setuptools python3-dev python3-pip -y 安装python编译依赖\n1sudo apt install -y build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev 配置vsftpd 1sudo vim /etc/vsftpd.conf 配置pip源 1cd 2sudo mkdir .pip 3cd .pip 4sudo touch pip.conf 5sudo vim pip.conf 粘贴以下内容到pip.conf\n[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = https://pypi.tuna.tsinghua.edu.cn 安装git 安装git\n1sudo apt install git git配置\n1git config --global user.name 名字 2git config --global user.email 邮箱 cd到家目录下的Downloads目录下，下载所有源码包\n1sudo wget https://gmplib.org/download/gmp/gmp-5.1.3.tar.bz2 2sudo wget https://crypto.stanford.edu/pbc/files/pbc-0.5.14.tar.gz 3sudo wget https://www.python.org/ftp/python/3.7.9/Python-3.7.9.tgz 4 5# charm和pypbc获取 6# 可以从github导入到gitee加快下载速度 7git clone https://gitee.com/liihoo/charm.git 8git clone https://gitee.com/liihoo/pypbc.git 安装GMP 1sudo tar -jxvf gmp-5.1.3.tar.bz2 2cd gmp-5.1.3/ 3sudo ./configure 4sudo make 5sudo make install 安装PBC 安装PBC\n1sudo tar -zxvf pbc-0.5.14.tar.gz 2cd pbc-0.5.14/ 3sudo ./configure 4sudo make 5sudo make install 添加libpbc到系统链接库\n1sudo vim /etc/ld.so.conf 写入以下内容\n1/usr/local/lib 更新动态库\n1sudo ldconfig 安装Python3.7.9 新建一个文件用于安装目录，比如/opt/python3/python3.7.9\n1sudo tar -zxvf Python-3.7.9.tgz 2sudo ./configure --prefix=/opt/python3/python3.7.9 3sudo make 4sudo make install 创建Python3.7.9的软连接。不要覆盖系统默认的版本\n1sudo ln -s /opt/python3/python3.7.9/bin/pip3 /usr/bin/pip3.7 2sudo ln -s /opt/python3/python3.7.9/bin/python3.7 /usr/bin/python3.7 3pip3.7 install pyparsing==2.2.1 安装Jupyter 1pip3.7 install jupyter notebook 打开家目录下的.bashrc添加jupyter路径\nvim .bashrc 更新配置\n1source .bashrc 生成配置文件\n1jupyter notebook --generate-config 使用python中的passwd()创建密码，终端输入ipython打开ipython并输入，复制打印的密码\n1In [1]: from notebook.auth import passwd 2In [2]: passwd() 打开配置文件\n1vim ~/.jupyter/jupyter_notebook_config.py 在文件末尾添加：\n1c.NotebookApp.allow_remote_access = True #允许远程连接 2c.NotebookApp.ip=\u0026#39;*\u0026#39; # 设置所有ip皆可访问 3c.NotebookApp.open_browser = False # 禁止自动打开浏览器 4c.NotebookApp.port =8888 #任意指定一个端口 5c.NotebookApp.password = u\u0026#39;sha:..\u0026#39; #之前复制的密码 安装charm-crypto 打开charm-crypto的GitHub地址，下载源码的压缩包 网络原因，需要想办法，最后打开xftp上传到Ubuntu\n1sudo unzip charm-dev.zip 打开configure.sh修改python配置文件位置指向python3.7.9的位置，如下\n1cd charm 2sudo ./configure.sh --python=/opt/python3/python3.7.9/bin/python3.7 3sudo make 4sudo make install 安装pypbc 打开pypbc.c文件，将第1338行注释掉，否则无法进行$Zr$上的除法运算\n1cd pypbc 2sudo python3.7 setup.py install 3sudo pip3.7 install pypbc 后续 删除所有自己安装的gmp库\n1sudo rm -rf /usr/local/lib/libgmp* 更新动态库\n1sudo ldconfig 常用的python库安装\n1pip3.7 install numpy scipy pandas matplotlib pycryptodome ","permalink":"https://mariosight.github.io/posts/ubuntu22.04%E4%B8%8Bcharm%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","summary":"\u003ch1 id=\"ubuntu2204lts-下python379charm-cryptopypbcjupyter环境搭建\"\u003eUbuntu22.04LTS 下Python3.7.9+Charm-Crypto+pypbc+Jupyter环境搭建\u003c/h1\u003e\n\u003ch2 id=\"参考文献\"\u003e参考文献\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/qq_33976344/article/details/115383904\"\u003eLinux安装Charm-crypto环境详细流程_android使用charm-crypto-CSDN博客\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1-前置工具\"\u003e1 前置工具\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e为了方便本地操作，先安装openssh-server和net-tools\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo apt install openssh-server net-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e连接到本地xshell以后，再进行如下安装\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo apt install gcc g++ make vim vsftpd wget m4 flex bison python3-setuptools python3-dev python3-pip -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e安装python编译依赖\u003c/p\u003e","title":"Ubuntu22.04LTS 下Python3.7.9+Charm-Crypto+pypbc+Jupyter环境搭建"},{"content":"南京之行：找小徐玩咯 2023-06-23 南京大屠杀纪念馆（铭记苦难，向往和平） 南京大屠杀纪念馆，一直很想去看看的，看日本动漫听日本歌曲也不代表我们会忘记那段屈辱悲惨的过去，我们会永远记得，永远记得日本军国主义对我们的同胞惨无人道的屠戮，永远记得他们犯下的所有令人唾弃的罪行，永远记得落后就要挨打的历史教训，我们永远记得\n在馆前有可以通过向纪念馆捐赠任意金额获得一枝白色花朵，献给在南京大屠杀中的遇难者，一开始我以为是在卖花，因为之前去北京的毛主席纪念堂的时候有人在卖，感觉这种行为不是很好，是在利用逝去的人们谋取利益，但是感觉这种捐赠的方式就很好，而且信息是公开到网站和公众号的，我也知道这笔钱一定会到纪念馆的日常开销中 矗立在馆前的一座雕塑，仿佛在向着天空咆哮 遇难者人数和南京大屠杀持续时间 到了展厅，全黑的墙壁，惨白的灯光，似乎都在诉说着那个年代的不公与凄惨，墙上一幅幅图片一段段文字，无不表达着对当时日本军队恶行的控诉，对深受苦难的中国人民的哀悼，因为感觉在场馆里面拍照是对那段历史的亵渎，所以只拍了一张我比较喜欢的话 刚刚入馆的标题 “我不是复仇主义者，我无意于把日本军国主义欠下我们的血债写在日本人民的账上。但是，我相信，忘记过去的苦难可能招致未来的灾祸”，在参观之后有一个笔记的留念上我也写下了这句话，我们对热爱和平的日本人民是欢迎的，但是我们在心里永远铭刻着这场灾难，为的是防止之后在发生这样惨绝人寰的事情 远东国际军事法庭法官梅汝璈 刻在石板上的数字，也刻在每个中国人心里；向往和平的女神像，她手中的和平鸽是否会一直飞下去呢 遇难者人数 向往和平的女神像 夫子庙街道（现代与历史的文化融合） 感受完历史的沉重，又来到了南京的秦淮区，夫子庙街道，人山人海，好不繁华，各种小吃店、商品店、饭店，给我的感觉是将历史文化与现代气息融合起来了，虽然我不是很喜欢这种夹杂着现代气息的文化景点，但也算是一种商业尝试吧 秦淮-戏院里（应该是一个饭店吧） 中国科举博物馆 “天下文枢”出自重建于明万历年间的南京文庙（即南京夫子庙），清初坊额上方的字为著名书法家陈澍所写。今坊额上的“天下文枢”四个大字选自颜真卿的字帖，它是步入文庙的第一道大门（来自百度百科） 这边好多人在排队，可能是去拍照吧，人流量有点太恐怖了（牵手手就不怕走丢啦 🤤） 天下文枢 在小桥上拍的照片，真的很有江南水乡的韵味，虽然亮起的灯有点出戏吧（，之前总是在电视里看着那些江南风景，现在终于看到了。听小徐说在苏州那边的江南水乡气息更加浓厚一些，有点想去看看了 河里的游船 河边的房子 灯火通明 2023-06-24： 中山陵（潮流沧海引，礼服号中山） 第二天！早上出来的时候下了雨，本来觉得下不久就会停，但是感觉南京的天空似乎不太愿意停下，不断下着细雨，时停时密的钟山，钟山又称紫金山，历史上便是知名的风景区，其历史可以追溯至中国的东晋时期。钟山风景名胜区现由两大区域构成，即东部主体钟山主体区域中山陵园风景区（包含中山陵景区、明孝陵景区、灵谷景区三大核心景区和其他区域景点）以及西部的区域（包括玄武湖景区和九华山区域）（还是百度百科），过来见一见老朱和老孙，了解一下民国和明朝时期的历史文化中山陵的这条路上好多人，对不起中山先生，看见这么多人来我也就放心了，也不缺我一个人，我还是去看看旁边的事迹展会吧（ 中山陵前的博爱坊 孙中山史迹展会 中山陵旁边就是音乐台，感觉这种民国时期的建筑风格的确更偏西式一点。这边好多鸽子，白鸽、灰鸽都有，合理怀疑这边是什么鸽子养殖基地（\n正面拍一下，上面停满了鸽子 侧面再来一张 美龄宫，当时的正式名称是国民政府主席官邸，国民政府从重庆迁回首都南京后，将此处设为蒋介石官邸，蒋介石常与宋美龄来此休息和度假，蒋介石也曾多次在此接待外国贵宾。老蒋我来了嗷，敢不敢跟我比划比划（，诶我身份证呢，老蒋你真是不讲武德，你太卑鄙了，你偷我身份证干嘛！（在美龄宫门前找不到身份证了呜呜呜，联系观光车也没有找到，在女朋友面前丢大人了） 外面是中式建筑的风格，里面却是西式的装潢 那个年代的老式汽车，经常出现在抗日剧里面的 “革命尚未成功，同志仍需努力” 中山先生千古 明孝陵（千秋帝业成春梦，万古江山作画屏） 明孝陵，是明代开国皇帝朱元璋和皇后马氏的合葬陵墓。因皇后谥“孝慈”，故名孝陵，作为中国明陵之首的明孝陵壮观宏伟，代表了明初建筑和石刻艺术的最高成就，影响了明清两代 500 多年帝王陵寝的形制（嗯，是的） 明孝陵 神圣功德碑楼，内有立于龟座（赑屃，bi xi）上的石碑，碑高 6.7 米，赑屃高 2.08 米，碑文由明成祖朱棣亲自撰写明太祖的功德 神功圣德碑 石像路神道，位于神功圣德碑亭之北，过五孔御河桥，列石像生十二对，自前向后依次为坐狮、立狮、坐獬豸（xie zhi）、立獬豸、卧驼、立驼、卧象、立象、坐麒麟、立麒麟、卧马、立马。石兽之后又有望柱一对、武臣二对、文臣二对 不要随意攀爬古遗迹雕塑啊，走在神道上看到有小孩子去攀爬我心疼的很，你等老朱从陵墓里面爬出来把你做成稻草人挂在上面（ 没有拍照片，因为当时下雨走路感觉不方便拍，来点网图 文武方门，陵宫的正门，不怎么下雨咯 文武方门 明楼，明楼为长方形城堡式建筑，以石条垒成，下为须弥座，通高 16.25 米，正中辟一门券，高 3.86 米。里面是楼梯，上去之后则是斜着的路面，雨天路滑，小心摔倒哦（ 明楼 明楼上还有 VR 体验陵墓遗迹，科技改变历史古迹？（ 登上明楼，视野开阔 逛了一天，也下了一天的小雨，走到出口时雨也停了，在池塘边看到正盛开的荷花，正是“惟有绿荷红菡萏，卷舒开合任天真”，令人心旷神怡 从钟山下来咯，出口旁边的荷花池 太平天国博物馆（始为黎民成半壁,终成皇帝败江山） 一刻都没有为逛完钟山而感到劳累,立刻赶到的地方是——瞻园中的太平天国历史博物馆（ 太平天国，太平天国是中国近代的一次大规模农民起义，其疆域最广阔之时曾占有中国半壁江山，在南京定都，发展到江南各个地区，但最后还是因为农民的阶级局限性而导致失败，可悲可叹 太平天国历史陈列 太平军攻破南京城 瞻园（名园一自邀游赏，未许凡人到此来） 瞻园是南京现存历史最久的明代古典园林、“江南四大名园”之一，也是 87 版红楼梦的取景地。跟小徐一起看的 87 版的红楼梦，感叹贾府的兴盛衰败，感慨红楼女子的凄惨命运。可能自己本身就是一个偏悲观的人，一直记得黛玉和湘云在中秋时节在凹晶馆联诗的那句“寒塘渡鹤影，冷月葬花魂”，还有黛玉葬花吟中的那句，“花谢花飞花满天，红消香断有谁怜”，盛世时期的诗句倒是没记住几个（\n古典园林风景 远处的亭子 经典的圆拱门 假山上的台阶 夜游南京（凤箫声动，玉壶光转，一夜鱼龙舞） 明早就要走了，从酒店里出来逛逛，走到百家湖那边了，突然想起辛弃疾的那首青玉案，“众里寻他千百度，蓦然回首，那人却在灯火阑珊处”，（转头一看，她不在，失落，继续往前走），南京的夜景，繁华的街道，又一次站在人生岔路口的我，也不知道未来该走向何方（什么青春伤痛文学） 百家湖文化馆，好炫酷的建筑，必须拍一张 百家湖夜景 凤凰台 在桥上拍的江宁眼摩天轮 再见了，南京，我们下次有缘还会再见的，不知下次再在这里咏诵着宋词又将是什么时候了呢\n","permalink":"https://mariosight.github.io/posts/%E5%8D%97%E4%BA%AC%E4%B9%8B%E8%A1%8C/","summary":"\u003ch3 id=\"南京之行找小徐玩咯\"\u003e南京之行：找小徐玩咯\u003c/h3\u003e\n\u003ch4 id=\"2023-06-23\"\u003e2023-06-23\u003c/h4\u003e\n\u003ch5 id=\"南京大屠杀纪念馆铭记苦难向往和平\"\u003e南京大屠杀纪念馆（铭记苦难，向往和平）\u003c/h5\u003e\n\u003cp\u003e\u003cstrong\u003e南京大屠杀纪念馆\u003c/strong\u003e，一直很想去看看的，看日本动漫听日本歌曲也不代表我们会忘记那段屈辱悲惨的过去，我们会永远记得，永远记得日本军国主义对我们的同胞惨无人道的屠戮，永远记得他们犯下的所有令人唾弃的罪行，永远记得落后就要挨打的历史教训，\u003cstrong\u003e我们永远记得\u003c/strong\u003e\u003c/p\u003e","title":"南京之行"},{"content":"","permalink":"https://mariosight.github.io/about/","summary":"about","title":"About"}]