<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go语言基础学习 | Mario&#39;s Blog</title>
<meta name="keywords" content="Golang">
<meta name="description" content="介绍
Go语言是一种静态、编译型、并发型的编程语言。它具有强类型、垃圾回收、快速编译等特性，属于C系语言的一种

[!note] 编译型vs解释型

编译型语言
优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。
缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。
解释型语言
优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。
缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。
混合型语言
既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。

源码文件


1、命令源码文件：
声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。
2、库源码文件
库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。
库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。
3、测试源码文件
名称以 test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数。">
<meta name="author" content="Mario">
<link rel="canonical" href="https://mariosight.github.io/posts/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f30f3898c112503bdb0d7b0f23ebf6d565ba747c01ec177e32d2b7fa74664fb3.css" integrity="sha256-8w84mMESUDvbDXsPI&#43;v21WW6dHwB7Bd&#43;MtK3&#43;nRmT7M=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://mariosight.github.io/favicon-mario.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://mariosight.github.io/favicon-mario.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mariosight.github.io/favicon-mario.png">
<link rel="apple-touch-icon" href="https://mariosight.github.io/favicon-mario.png">
<link rel="mask-icon" href="https://mariosight.github.io/favicon-mario.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://mariosight.github.io/posts/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });
        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style><meta property="og:title" content="Go语言基础学习" />
<meta property="og:description" content="介绍
Go语言是一种静态、编译型、并发型的编程语言。它具有强类型、垃圾回收、快速编译等特性，属于C系语言的一种

[!note] 编译型vs解释型

编译型语言
优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。
缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。
解释型语言
优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。
缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。
混合型语言
既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。

源码文件


1、命令源码文件：
声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。
2、库源码文件
库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。
库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。
3、测试源码文件
名称以 test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mariosight.github.io/posts/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-12T16:57:34+00:00" />
<meta property="article:modified_time" content="2024-06-12T16:57:34+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go语言基础学习"/>
<meta name="twitter:description" content="介绍
Go语言是一种静态、编译型、并发型的编程语言。它具有强类型、垃圾回收、快速编译等特性，属于C系语言的一种

[!note] 编译型vs解释型

编译型语言
优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。
缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。
解释型语言
优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。
缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。
混合型语言
既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。

源码文件


1、命令源码文件：
声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。
2、库源码文件
库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。
库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。
3、测试源码文件
名称以 test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mariosight.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Go语言基础学习",
      "item": "https://mariosight.github.io/posts/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go语言基础学习",
  "name": "Go语言基础学习",
  "description": "介绍 Go语言是一种静态、编译型、并发型的编程语言。它具有强类型、垃圾回收、快速编译等特性，属于C系语言的一种\n[!note] 编译型vs解释型\n编译型语言\n优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。\n缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。 解释型语言\n优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。 缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。 混合型语言 既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。 源码文件 1、命令源码文件： 声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。 2、库源码文件 库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。 库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。 3、测试源码文件 名称以 test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数。\n",
  "keywords": [
    "Golang"
  ],
  "articleBody": "介绍 Go语言是一种静态、编译型、并发型的编程语言。它具有强类型、垃圾回收、快速编译等特性，属于C系语言的一种\n[!note] 编译型vs解释型\n编译型语言\n优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。\n缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。 解释型语言\n优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。 缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。 混合型语言 既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。 源码文件 1、命令源码文件： 声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。 2、库源码文件 库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。 库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。 3、测试源码文件 名称以 test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数。\n输入输出 fmt中输入函数Scanln\n1. 使用\"\u0026\"获取变量的内存地址(即取变量内存地址的运算符)，通过键盘输入为变量指向的内存地址赋初值。 2. fmt.Scanln是一个阻塞的函数，如果它获取不到数据就会一直阻塞哟。 3. fmt.Scanln可以接收多个参数，用户输入参数默认使用空格或者回车换行符分割输入设备传入的参数，直到接收所有的参数为止 fmt中的输出函数Println（ln表示自动换行）\n1. Println格式使用其操作数的默认格式，并写入标准输出。 2. 始终在操作数之间添加空格，并追加换行符。 3. 它返回写入的字节数和遇到的任何写入错误。 注意，如果需要输出如%s,%T这种类型，则需要使用Printf，这个跟C是类似的\n1fmt.Printf(\"type: %T\",str) 数据结构 数据类型 数类型 uint8 无符号 8位整型 (0 到 255) uint16 无符号 16位整型 (0 到 65535) uint32 无符号 32位整型 (0 到 4294967295) uint64 无符号 64位整型 (0 到 18446744073709551615) int8 有符号 8位整型 (-128 到 127) int16 有符号 16位整型 (-32768 到 32767) int32 有符号 32位整型 (-2147483648 到 2147483647) int64 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) float32和float64 范围分别为3.4e38和1.8e308\ncomplex64和complex128\n字符类型 uint8类型，或者叫 byte 型，代表一个ASCII码字符。\nrune类型，代表一个 UTF-8字符。 rune 类型是 int32 的别名，用于表示一个Unicode码点（Unicode code point）。每个rune对应一个Unicode字符，可以表示任何语言的字符（包括中文、表情符号等） Go的字符串默认以UTF-8编码存储。当遍历字符串时，若用 for range，会自动按 rune 为单位迭代，而非字节：\n1s := \"Hello 世界\" 2for _, r := range s { 3// r 的类型是 rune 4fmt.Printf(\"%c \", r) 5} 6// 输出: H e l l o 世 界 这里是对于range的解释：golang中使用for range 遍历字符串时常遇到的bug，byte和rune类型，源码分析 - Harven - 博客园\n数组和切片 数组（Array）和切片（Slice）的区别其实是数组在定义的时候已经规定好了长度，而切片并没有规定长度 数组是需要指定初始化长度（或者叫做容量）的序列，在定义时可以直接设置初始值，如果不设置，初始值为默认值 切片是一个拥有相同类型元素的可变长度的序列，可以通过append函数添加元素\n两者的对比 ![[Pasted image 20240809083724.png]] 代码书写 切片可以用内置函数 make 来创建，这也是你创建动态数组的方式。 make 函数会分配一个元素为零值的数组并返回一个引用了它的切片： 1a := make([]int, 5) // len(a)=5 要指定它的容量，需向 make 传入第三个参数\n1arr := [5]int{0, 1, 2, 3, 4} //创建一个数组 2s1 := arr[0:3] //创建一个子切片,[0:3)左闭右开 3s2 := make([]int, 3, 4) //创建一个切片，长度为3，初始元素为0，容量为4 4s1 = append(s1, 8) //追加一个元素 5s2 = append(s2, 1) //追加一个元素 6//切片比较好的创建方式为make([]int,0,cap) 子切片 通过[start:end]来获得子切片，arr[start:end]获取的是[start,end)之间的元素，左闭右开 arr[:end]获得[0,end)之间的元素 arr[start:]获得[start,len(arr))之间的元素 子切片与原切片共享底层数组 理解slice 实际上是Go中特殊的ArrayList，但是没有插入和删除的操作，只有append操作，下面稍微写了一下对于slice的insert和delete，在这其中使用了copy函数：当我们在Go语言中需要将一个切片的内容复制到另一个切片时，可以使用内置的copy()函数，copy()函数用于将源切片中的元素复制到目标切片中。 slice的零值是nil，通过[]int这种方式来创建切片时首先会创建一个对应的底层数组 1//实现指定位置插入元素 2func insert(slice []int,value int,index int) []int { 3slice = append(slice, 0) //扩展一个空间 4copy(slice[index+1:],slice[index:]) //向后移动 5slice[index] = value //插入元素 6return slice 7} 8//实现指定位置删除元素 9func delete(slice []int,index int) []int { 10copy(slice[index:],slice[index+1:]) //向前移动 11return slice[:len(slice)-1] //删除最后一个元素 12} 练习切片的一个小程序，通过灰度图展示公式\n1package main 2 3import \"golang.org/x/tour/pic\" 4 5func Pic(dx, dy int) [][]uint8 { 6\tans := make([][]uint,dy) 7\tfor y:=0;y\u003cdy;y++{ 8\trow := make([]uint8,dx) 9\tfor x:=0;x\u003cdx;x++{ 10\trow[x] = uint8(x%(y+1)) 11\t} 12\tans[y]=row 13\t} 14\treturn ans 15} 16 17func main() { 18\tpic.Show(Pic) 19} 字符串 字符串用\"abc\"表示，单个字符用'a'表示 字符串可以通过索引访问字符\n1s:=\"abcde\" 2print(s[0]) 字符串可以通过切片访问连续字符\n1s:=\"abcde\" 2print(s[0:3]) 统计字符串的个数要用特殊的方法\n1s:=\"abcde\" 2print(utf8.RuneCountInString(s))} 将字符编码转换为字符\n1s:=\"abcde\" 2print(string(s[1])) 遍历字符串的每一个字符\n1s:=\"我爱你中国\" 2cs:=[]rune(s) 3for_,ch:=range cs{ 4\tfmt.Println(string(ch)) 5} 使用buffer累加字符串\n1var bf bytes.Buffer 2for i:=0;i\u003c10;i++{ 3\tfmt.Fprintf(\u0026bf,\"a%d\",i) 4} 5s:=bf.String() 6fmt.Println(s) 指针 \u0026符号会【生成】一个指向其作用对象的指针。 *符号表示指针指向的【底层的值】 1package main 2import \"fmt\" 3func main() { 4\ti, j := 42, 2701 5\tp := \u0026i // p为i的指针 6\tfmt.Println(*p) // 通过指针显示的是i的值 7\t*p = 21 // 通过指针修改的是i的值 8\tfmt.Println(i) 9\tp = \u0026j // 将p改为j的指针 10\t*p = *p / 37 // 通过指针操作的是j的值，除以37的结果重新通过指针赋给j 11\tfmt.Println(j) 12} 结构体定义 定义类型 定义类型的不同方式，使用也不相同\n1// BigServer type A=B 2type BigServer = server 3// SmellServer type A B 4type SmellServer server 5 6service1 := SmellServer{} 7service2 := BigServer{} 8server(service1).open() 9service2.open() 初始化 Go没有构造函数，所以new直接分配内存然后把内存都置0\n1man1 := Person{name: \"李四\"} 2man1.Walk(man1.name) 3man2 := new(Person) 4man2.name = \"王五\" 5man2.Walk(man2.name) 方法接收器 用于定义结构体对应的方法（也可以为非结构体类型声明方法） 只能为在同一个包中定义的接收者类型声明方法，而不能为其它别的包中定义的类型（包括 int 之类的内置类型）声明方法\n1// 结构体接收器 2func (p Person) ChangeName(newName string) { 3 p.name = newName 4} 5// 指针接收器 6func (p *Person) ChangeAge(newAge int) { 7 p.age = newAge 8} 9// 结构体接收器，内容不会改变 10man1.ChangeName(\"赵六\") 11// 指针接收器，内容会改变，我直接遇事不决用指针 12man1.ChangeAge(30) 13fmt.Println(man1) 链表 哈希表 [[哈希表（Hash-Table）]] ![[哈希表（Hash-Table）#Go中如何使用HashTable]]\nGo之旅中的一个练习，用的是比较简单的map，实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。 函数 wc.Test 会为此函数执行一系列测试用例，并输出成功还是失败\n1package main 2 3import ( 4\t\"golang.org/x/tour/wc\" 5\t\"strings\" 6) 7func WordCount(s string) map[string]int { 8\tv := strings.Fields(s) //Field函数直接分割 9\tn := len(v) 10\tx := make(map[string]int) 11\tfor i:=0;i\u003cn;i++ { 12\tx[v[i]]++ 13\t} 14\treturn x 15} 16 17func main() { 18\twc.Test(WordCount) 19} 控制结构 for 类似 while 的无限循环 fori 一般的按照下标循环 forr 最为特殊的 range 遍历，可以用于map遍历\n1for i := 0; i \u003c len(arr); i++ { 2fmt.Printf(\" index = %d,number = %d \\n\", i, arr[i]) 3} 4for index, value := range arr{ 5fmt.Printf(\" index = %d,number = %d \\n\", index, value) 6} if-else：没什么可以记录的，跟其他的语言一样的\n函数调用 Go 语言选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝\n无需声明原型 支持不定变参 支持多返回值 支持命名返回参数 函数也是一种类型，一个函数可以复制给变量；可以作为参数传递给其他函数 不支持嵌套（一个包不能有重名的函数） 不支持重载 不支持默认参数 整数与数组类型 如下所示的函数 myFunction 接收了两个参数，整型变量 i 和数组 arr，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 myFunction 函数调用前后分别打印两个参数的地址，最后的结果main函数中的参数地址与myFunction中的地址完全不同，所以能够证明Go 语言的整型和数组类型都是值传递的\n1func myFunction1(i int, arr [2]int) { 2\tfmt.Printf(\"in my_funciton - i=(%d, %p) arr=(%v, %p)\\n\", i, \u0026i, arr, \u0026arr) 3} 4 5func main() { 6\ti := 30 7\tarr := [2]int{66, 77} 8\tfmt.Printf(\"before calling - i=(%d, %p) arr=(%v, %p)\\n\", i, \u0026i, arr, \u0026arr) 9\tmyFunction1(i, arr) 10\tfmt.Printf(\"after calling - i=(%d, %p) arr=(%v, %p)\\n\", i, \u0026i, arr, \u0026arr) 11} 结构体与指针类型 传递结构体时：会拷贝结构体中的全部内容 传递结构体指针时：会拷贝结构体指针 1func myFunction2(a MyStruct, b *MyStruct) { 2 a.i = 31 3 b.i = 41 4 fmt.Printf(\"in my_function - a=(%d, %p) b=(%v, %p)\\n\", a, \u0026a, b, \u0026b) 5} 6func main() { 7a := MyStruct{i: 30} 8b := \u0026MyStruct{i: 40} 9fmt.Printf(\"before calling - a=(%d, %p) b=(%v, %p)\\n\", a, \u0026a, b, \u0026b) 10myFunction2(a, b) 11fmt.Printf(\"after calling - a=(%d, %p) b=(%v, %p)\\n\", a, \u0026a, b, \u0026b) 12} 方法与函数 方法 (func (c *Context) String)： 方法的第一个参数是一个接收者（receiver），即 c *Context，表示该方法属于 Context 类型。 方法的调用方式是通过类型的实例来调用，例如 context.String(...)，其中 context 是 Context 类型的一个实例。 表达的是 String 操作是 Context 类型的一部分，是 Context 对象的一个行为。 更适合表示“某种类型的实例应该具备的行为”。 函数 (func String(c *Context))： 一个普通的函数，它的参数是 c *Context，表示函数接收一个 *Context 类型的参数。 函数的调用方式是直接调用，并传入参数，例如 String(context, ...)，参数列表名称在前，类型在后，可以有多返回值，返回值也可以有名称 是独立于 Context 类型的一个函数，只是恰好接受一个 Context 类型的参数。 更适合表示“一般性的操作或工具函数”，而不是某种类型的固有行为。 方法与指针重定向 1func (v *Vertex) Scale(f float64) { 2\tv.X = v.X * f 3\tv.Y = v.Y * f 4} 5 6func ScaleFunc(v *Vertex, f float64) { 7\tv.X = v.X * f 8\tv.Y = v.Y * f 9} 比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：\n1var v Vertex 2ScaleFunc(v, 5) // 编译错误！ 3ScaleFunc(\u0026v, 5) // OK 而接收者为指针的的方法被调用时，接收者既能是值又能是指针：\n1var v Vertex 2p := \u0026Vertex{4, 3} 3p.Scale(3) //OK 4(*p).Scale(8) //OK 对于语句 v.Scale(5) 来说，即便 v 是一个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (\u0026v).Scale(5)。 反之同理，接受一个值作为参数的函数必须接受一个指定类型的值，而以值为接收者的方法被调用时，接收者既能为值又能为指针，这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()，其实就是遇到不同情况自动转换。\n接口 接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息。如下图所示，接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。 在 Java 中：实现接口需要显式地声明接口并实现所有方法，在接口中不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用\n1public interface MyInterface { 2 public String hello = \"Hello\"; 3 public void sayHello(); 4} 5 6public class MyInterfaceImpl implements MyInterface { 7 public void sayHello() { 8 System.out.println(MyInterface.hello); 9 } 10} 在 Go 中：实现接口的所有方法就隐式地实现了接口，但是在接口中我们只能定义方法签名，不能包含成员变量\n1type error interface { 2\tError() string 3} 4type RPCError struct { 5\tCode int64 6\tMessage string 7} 8func (e *RPCError) Error() string { 9\treturn fmt.Sprintf(\"%s, code=%d\", e.Message, e.Code) 10} Java中的类必须显式地声明实现的接口，与Java不同的是Go语言中接口的实现都是隐式的，我们只需要实现 Error() string 方法就实现了 error 接口\n接口方法 接口就是规定了一个需要实现的方法列表，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口 我们定义的 Singer 接口类型，它包含一个 Sing 方法。\n1type Singer interface { 2\tSing() 3} 然后有一个 Bird 结构体\n1type Bird struct {} 因为 Singer 接口只包含一个 Sing 方法，所以只需要给 Bird 结构体添加一个 Sing 方法就可以满足 Singer 接口的要求。\n1// Sing Bird类型的Sing方法 2func (b Bird) Sing() { 3\tfmt.Println(\"汪汪汪\") 4} 为什么要用接口呢，因为有时不止一个类型需要实现这个方法，可能有多个结构体需要 Sing() 这个方法，这时就可以使用接口类型，把所有会叫的动物当成 Singer 类型来处理\n1package main 2 3import \"fmt\" 4 5type Sayer interface { 6 Say() 7} 8type Cat struct { 9} 10 11type Dog struct{} 12 13func (c *Cat) Say() { 14 fmt.Println(\"cat miao\") 15} 16func (d *Dog) Say() { 17 fmt.Println(\"dog woof\") 18} 19func Hungry(s Sayer) { 20 s.Say() 21} 22 23func main() { 24 var c Cat 25 var d Dog 26 Hungry(\u0026c) 27 Hungry(\u0026d) 28} Stringer是 fmt 包中定义的 Stringer 是最普遍的接口之一，是一个可以用字符串描述自己的类型，任何实现了 String() string 方法的类型都隐式满足该接口。fmt 包（还有很多包）都通过此接口来打印值，可以规范化对应值的输出\n1package main 2 3import \"fmt\" 4 5type IPAddr [4]byte 6 7// TODO: 为 IPAddr 添加一个 \"String() string\" 方法。 8func (I IPAddr) String() string{ 9\treturn fmt.Sprintf(\"%v.%v.%v.%v\",I[0],I[1],I[2],I[3]) 10} 11func main() { 12\thosts := map[string]IPAddr{ 13\t\"loopback\": {127, 0, 0, 1}, 14\t\"googleDNS\": {8, 8, 8, 8}, 15\t} 16\tfor name, ip := range hosts { 17\tfmt.Printf(\"%v: %v\\n\", name, ip) 18\t} 19} 与 fmt.Stringer 类似，error 类型是一个内建接口\n1type error interface { 2 Error() string 3} 类似的还有，sort接口，json序列化，io读写，以及http的请求处理 rot13Reader的实现，一个接口组合的实现\n1package main 2 3import ( 4\t\"io\" 5\t\"os\" 6\t\"strings\" 7) 8 9type rot13Reader struct { 10\tr io.Reader 11} 12 13func rot13(c byte) byte { 14\tswitch { 15\tcase c \u003e= 'A' \u0026\u0026 c \u003c= 'Z': 16\treturn 'A' + (c-'A'+13)%26 17\tcase c \u003e= 'a' \u0026\u0026 c \u003c= 'z': 18\treturn 'a' + (c-'a'+13)%26 19\tdefault: 20\treturn c 21\t} 22} 23 24func (r *rot13Reader) Read(b []byte) (n int, err error) { 25\t// 要调用底层的Read 26 n, err = r.r.Read(b) 27 for i := 0; i \u003c n; i++ { 28 b[i] = rot13(b[i]) 29 } 30 return n, err 31} 32 33func main() { 34\ts := strings.NewReader(\"Lbh penpxrq gur pbqr!\") 35\tr := rot13Reader{s} 36\tio.Copy(os.Stdout, \u0026r) 37} 图像生成器\n1package main 2 3import ( 4\t\"fmt\" 5\t\"golang.org/x/tour/pic\" 6\t\"image\" 7\t\"image/color\" 8) 9 10type Image struct{ 11\tWidth int 12\tHeight int 13} 14// Bounds image.Rectangle 15func (img Image)Bounds() image.Rectangle{ 16\treturn image.Rect(0,0,img.Width,img.Height) 17} 18 19// Color color.RGBModel 20func (img Image) ColorModel() color.Model{ 21\treturn color.RGBAModel 22} 23// At color.Color 24func (img Image) At(x,y int) color.Color{ 25\tv := uint8(x^y) 26\treturn color.RGBA{v,v,255,255} 27} 28 29func main() { 30\tm := Image{256,256} 31\tpic.ShowImage(m) 32} 错误（error） Go 程序使用 error 值来表示错误状态。通常函数会返回一个 error 值，调用它的代码应当判断这个错误是否等于 nil 来进行错误处理。\n1package main 2 3import ( 4\t\"fmt\" 5\t\"math\" 6) 7type ErrNegativeSqrt struct{ 8\tValue float64\t9} 10 11func Sqrt(x float64) (float64, error) { 12\tif x\u003c0 { 13\treturn x , ErrNegativeSqrt{Value: x} 14\t}else { 15\treturn math.Sqrt(x),nil 16\t} 17} 18// 重写Error方法，输出更多错误提示信息 19func (e ErrNegativeSqrt) Error() string{ 20\treturn fmt.Sprintf(\"cannot Sqrt negative number: %v\",float64(e)) 21} 22 23func main() { 24\tfmt.Println(Sqrt(2)) 25\tfmt.Println(Sqrt(-2)) 26} 接口值 接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体值之外，还需要记录这个值属于的类型。也就是说接口值由“类型”和“值”组成。 接口值（Interface Value） 本质上是一个动态容器，它可以持有任意具体类型的值，并在运行时记录类型信息，隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备\nnil 接口值既不保存值也不保存类型，为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个具体方法的类型 指定了零个方法的接口值被称为空接口，空接口可保存任何类型的值，空接口被用来处理未知类型的值\n类型断言 类型断言是一种可以从接口值中提取其动态类型具体值的方法，给一个什么值，他就变成对应的类型 该语句断言接口值 i 保存了具体类型 Type，并将其底层类型为 Type 的值赋予变量 t，如果未保存，那么该语句就会触发panic\n1\tt := i.(T) 为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。\n1\tt, ok := i.(T) 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true 否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生 panic\n类型选择 类型选择 是一种按顺序从几个类型断言中选择分支的结构，它们针对给定接口值所存储的值的类型进行比较\n1func Describe(s Shape) { 2 switch v := s.(type) { 3 case Circle: 4 fmt.Printf(\"圆形，半径: %v\\n\", v.Radius) 5 case Rectangle: 6 fmt.Printf(\"矩形，长: %v, 宽: %v\\n\", v.Width, v.Height) 7 default: 8 fmt.Println(\"未知形状\") 9 } 10} 11 12func main() { 13 Describe(Circle{Radius: 3}) // 输出：圆形，半径: 3 14 Describe(Rectangle{4, 5}) // 输出：矩形，长: 4, 宽: 5 15} 闭包（closure） 闭包（closure）是指一个函数可以捕获并引用其外部作用域中的变量，即使在这些变量的作用域已经结束之后，换句话说，该函数被“绑定”到了这些变量。闭包的实现依赖于函数本身以及它所引用的环境\n1i := 13 2a := func() { 3 fmt.Println(\"i = \", i) 4} 5a() 延迟绑定：闭包捕获的是变量的引用，而不是它在循环中每次迭代的值\n1func Delay() { 2 fns := make([]func(), 0, 10) 3 for i := 0; i \u003c 10; i++ { 4 fns = append(fns, func() { 5 fmt.Println(\"i = \", i) 6 }) 7 } 8 //执行的时候i = 10，因为闭包捕获的是变量i的引用,而不是值 9 //因此在循环中使用闭包时需要小心处理 10 //？？为什么我这里是i从0-9，好诡异啊 11 for _, fn := range fns { 12 fn() 13 } 14} 杂项记录 查看对应变量的类型 1//使用%T 2fmt.Printf(\"type: %T\", value) 3 4//使用reflect下的Typeof，要引入reflect包 5fmt.Println(reflect.Typeof(value)) 输出其命令行参数 1package main 2 3import ( 4\"fmt\" 5\"os\" 6) 7 8func main() { 9fmt.Println(\"Hello, World!\") 10var s, sep string 11for _, arg := range os.Args[0:] { //输出目标文件命令的名字 12s += sep + arg 13sep = \" \" 14} 15//for i := 1; i \u003c len(os.Args); i++ { 16// s += sep + os.Args[i] 17// sep = \" \" 18//} 19fmt.Println(s) 20} OK的使用 在 Go 语言中，ok 通常与 map 结合使用，用于判断某个键（key）是否存在于 map 中，是 Go 中一种常见的“安全读取”模式。 通过第二个返回值 ok（布尔类型）可以判断键是否存在：\n1 m := map[string]int{\"apple\": 5, \"banana\": 3} 2 3 // 检查键是否存在 4 value, ok := m[\"apple\"] 5 if ok { 6 fmt.Println(\"apple 存在，值是\", value) 7 } else { 8 fmt.Println(\"apple 不存在\") 9 } 在练习LeetCode的时候也看到有高级的语句记录了下来，对于ok在if中的使用含义，经常在map中使用：\n1func learnErrorHandling() { 2// \", ok\"用来判断有没有正常工作 3m := map[int]string{3: \"three\", 4: \"four\"} 4if x, ok := m[1]; !ok { // ok 为false，因为m中没有1 5fmt.Println(\"no one there\") 6} else { 7fmt.Print(x) // 如果x在map中的话，x就是那个值喽。 8} 9} [!note] 上述代码中，在if语句中，ok这个bool变量的含义是，如果其中有1这个key，那么其value赋值给x然后令ok为true，如果没有则令ok为false\n引用包时出错 包在之后的代码中并未引用，可以通过在包名前加_进行匿名引用\n定义变量 var后面定义有默认类型，如果不想按照默认类型来的话，就需要自己写 go是强类型语言，不做任何类型转换 或者直接:=进行赋值\n1var a = 13 // 默认为int 2var b uint =15 3a := 13 求string的长度 len()函数求出来的是字节的长度，而不是字符长度 应该用utf8.RuneCountInString(\"你好\")进行求解\n对二维数组进行排序 这里的 slices.SortFunc 通过传入一个比较函数（func(p, q []int) int）来实现对 intervals 进行排序 比较函数：func(p, q []int) int。它对两个元素 p 和 q 进行比较。\n如果返回值 \u003c 0，表示 p 应排在 q 之前。 如果返回值 \u003e 0，表示 q 应排在 p 之前。 如果返回值 = 0，表示 p 和 q 的顺序无所谓。 1slices.SortFunc(intervals, func(p, q []int) int { return p[0] - q[0] }) ",
  "wordCount" : "7522",
  "inLanguage": "zh",
  "datePublished": "2024-06-12T16:57:34Z",
  "dateModified": "2024-06-12T16:57:34Z",
  "author":{
    "@type": "Person",
    "name": "Mario"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mariosight.github.io/posts/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mario's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mariosight.github.io/favicon-mario.png"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mariosight.github.io/" accesskey="h" title="Mario&#39;s Blog (Alt + H)">Mario&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mariosight.github.io/" title="Mario&#39;s Blog">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://mariosight.github.io/archives/" title="Archieves">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://mariosight.github.io/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://mariosight.github.io/search/" title="Search">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://mariosight.github.io/about/" title="About">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Go语言基础学习
    </h1>
    <div class="post-meta"><span title='2024-06-12 16:57:34 +0000 UTC'>2024-06-12</span>&nbsp;·&nbsp;7522 字&nbsp;·&nbsp;Mario

</div>
  </header> <aside id="toc-container" class="toc-container wide">
        <div class="toc">
            <details  open>
                <summary accesskey="c" title="(Alt + C)">
                    <span class="details">目录</span>
                </summary>

                <div class="inner"><ul>
                        <li>
                            <a href="#%e4%bb%8b%e7%bb%8d" aria-label="介绍">介绍</a></li>
                        <li>
                            <a href="#%e6%ba%90%e7%a0%81%e6%96%87%e4%bb%b6" aria-label="源码文件">源码文件</a></li>
                        <li>
                            <a href="#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba" aria-label="输入输出">输入输出</a></li>
                        <li>
                            <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="数据结构">数据结构</a><ul>
                                    
                        <li>
                            <a href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="数据类型">数据类型</a></li>
                        <li>
                            <a href="#%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87" aria-label="数组和切片">数组和切片</a></li>
                        <li>
                            <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="字符串">字符串</a></li>
                        <li>
                            <a href="#%e6%8c%87%e9%92%88" aria-label="指针">指针</a></li>
                        <li>
                            <a href="#%e7%bb%93%e6%9e%84%e4%bd%93%e5%ae%9a%e4%b9%89" aria-label="结构体定义">结构体定义</a><ul>
                                    
                        <li>
                            <a href="#%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b" aria-label="定义类型">定义类型</a></li>
                        <li>
                            <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="初始化">初始化</a></li>
                        <li>
                            <a href="#%e6%96%b9%e6%b3%95%e6%8e%a5%e6%94%b6%e5%99%a8" aria-label="方法接收器">方法接收器</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e9%93%be%e8%a1%a8" aria-label="链表">链表</a></li>
                        <li>
                            <a href="#%e5%93%88%e5%b8%8c%e8%a1%a8" aria-label="哈希表">哈希表</a></li>
                        <li>
                            <a href="#%e6%8e%a7%e5%88%b6%e7%bb%93%e6%9e%84" aria-label="控制结构">控制结构</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8" aria-label="函数调用">函数调用</a><ul>
                                    
                        <li>
                            <a href="#%e6%95%b4%e6%95%b0%e4%b8%8e%e6%95%b0%e7%bb%84%e7%b1%bb%e5%9e%8b" aria-label="整数与数组类型">整数与数组类型</a></li>
                        <li>
                            <a href="#%e7%bb%93%e6%9e%84%e4%bd%93%e4%b8%8e%e6%8c%87%e9%92%88%e7%b1%bb%e5%9e%8b" aria-label="结构体与指针类型">结构体与指针类型</a></li>
                        <li>
                            <a href="#%e6%96%b9%e6%b3%95%e4%b8%8e%e5%87%bd%e6%95%b0" aria-label="方法与函数">方法与函数</a><ul>
                                    
                        <li>
                            <a href="#%e6%96%b9%e6%b3%95%e4%b8%8e%e6%8c%87%e9%92%88%e9%87%8d%e5%ae%9a%e5%90%91" aria-label="方法与指针重定向">方法与指针重定向</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e6%8e%a5%e5%8f%a3" aria-label="接口">接口</a><ul>
                                    
                        <li>
                            <a href="#%e6%8e%a5%e5%8f%a3%e6%96%b9%e6%b3%95" aria-label="接口方法">接口方法</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e9%94%99%e8%af%aferror" aria-label="错误（error）">错误（error）</a><ul>
                                    
                        <li>
                            <a href="#%e6%8e%a5%e5%8f%a3%e5%80%bc" aria-label="接口值">接口值</a><ul>
                                    
                        <li>
                            <a href="#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80" aria-label="类型断言">类型断言</a></li>
                        <li>
                            <a href="#%e7%b1%bb%e5%9e%8b%e9%80%89%e6%8b%a9" aria-label="类型选择">类型选择</a></li></ul>
                        </li></ul>
                        </li>
                        <li>
                            <a href="#%e9%97%ad%e5%8c%85closure" aria-label="闭包（closure）">闭包（closure）</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e6%9d%82%e9%a1%b9%e8%ae%b0%e5%bd%95" aria-label="杂项记录">杂项记录</a><ul>
                                    
                        <li>
                            <a href="#%e6%9f%a5%e7%9c%8b%e5%af%b9%e5%ba%94%e5%8f%98%e9%87%8f%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="查看对应变量的类型">查看对应变量的类型</a></li>
                        <li>
                            <a href="#%e8%be%93%e5%87%ba%e5%85%b6%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0" aria-label="输出其命令行参数">输出其命令行参数</a></li>
                        <li>
                            <a href="#ok%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="OK的使用">OK的使用</a></li>
                        <li>
                            <a href="#%e5%bc%95%e7%94%a8%e5%8c%85%e6%97%b6%e5%87%ba%e9%94%99" aria-label="引用包时出错">引用包时出错</a></li>
                        <li>
                            <a href="#%e5%ae%9a%e4%b9%89%e5%8f%98%e9%87%8f" aria-label="定义变量">定义变量</a></li>
                        <li>
                            <a href="#%e6%b1%82string%e7%9a%84%e9%95%bf%e5%ba%a6" aria-label="求string的长度">求string的长度</a></li>
                        <li>
                            <a href="#%e5%af%b9%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e8%bf%9b%e8%a1%8c%e6%8e%92%e5%ba%8f" aria-label="对二维数组进行排序">对二维数组进行排序</a>
                        </li>
                    </ul>
                    </li>
                    </ul>
                </div>
            </details>
        </div>
    </aside>
    <script>
        let activeElement;
        let elements;
        window.addEventListener('DOMContentLoaded', function (event) {
            checkTocPosition();

            elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }, false);

        window.addEventListener('resize', function (event) {
            checkTocPosition();
        }, false);

        window.addEventListener('scroll', () => {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement) {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }, false);

        const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
        const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
        const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

        function checkTocPosition() {
            const width = document.body.scrollWidth;

            if (width - main - (toc * 2) - (gap * 4) > 0) {
                document.getElementById("toc-container").classList.add("wide");
            } else {
                document.getElementById("toc-container").classList.remove("wide");
            }
        }

        function getOffsetTop(element) {
            if (!element.getClientRects().length) {
                return 0;
            }
            let rect = element.getBoundingClientRect();
            let win = element.ownerDocument.defaultView;
            return rect.top + win.pageYOffset;
        }
    </script>
  <div class="post-content"><h3 id="介绍">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍">#</a></h3>
<p>Go语言是一种静态、编译型、并发型的编程语言。它具有强类型、垃圾回收、快速编译等特性，属于C系语言的一种</p>
<blockquote>
<p>[!note] 编译型vs解释型</p>
<ol>
<li>编译型语言<br>
<strong>优点</strong>：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。<br>
<strong>缺点</strong>：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</li>
<li>解释型语言<br>
<strong>优点</strong>：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。
<strong>缺点</strong>：每次运行的时候都要解释一遍，性能上不如编译型语言。</li>
<li>混合型语言
既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。</li>
</ol></blockquote>
<h3 id="源码文件">源码文件<a hidden class="anchor" aria-hidden="true" href="#源码文件">#</a></h3>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/mariosight/image/picture/20241230114315057.png" alt="image.png"  />

<strong>1、命令源码文件：</strong>
声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。
<strong>2、库源码文件</strong>
库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。
库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。
<strong>3、测试源码文件</strong>
名称以 test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数。</p>
<h3 id="输入输出">输入输出<a hidden class="anchor" aria-hidden="true" href="#输入输出">#</a></h3>
<p>fmt中输入函数Scanln</p>
<pre tabindex="0"><code>1. 使用&#34;&amp;&#34;获取变量的内存地址(即取变量内存地址的运算符)，通过键盘输入为变量指向的内存地址赋初值。
2. fmt.Scanln是一个阻塞的函数，如果它获取不到数据就会一直阻塞哟。
3. fmt.Scanln可以接收多个参数，用户输入参数默认使用空格或者回车换行符分割输入设备传入的参数，直到接收所有的参数为止
</code></pre><p>fmt中的输出函数Println（ln表示自动换行）</p>
<pre tabindex="0"><code>1. Println格式使用其操作数的默认格式，并写入标准输出。
2. 始终在操作数之间添加空格，并追加换行符。
3. 它返回写入的字节数和遇到的任何写入错误。
</code></pre><p>注意，如果需要输出如%s,%T这种类型，则需要使用Printf，这个跟C是类似的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type: %T&#34;</span><span class="p">,</span><span class="nx">str</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="数据结构">数据结构<a hidden class="anchor" aria-hidden="true" href="#数据结构">#</a></h3>
<h4 id="数据类型">数据类型<a hidden class="anchor" aria-hidden="true" href="#数据类型">#</a></h4>
<p><strong>数类型</strong>
uint8    无符号 8位整型 (0 到 255)
uint16   无符号 16位整型 (0 到 65535)
uint32   无符号 32位整型 (0 到 4294967295)
uint64   无符号 64位整型 (0 到 18446744073709551615)
int8     有符号 8位整型 (-128 到 127)
int16    有符号 16位整型 (-32768 到 32767)
int32    有符号 32位整型 (-2147483648 到 2147483647)
int64    有符号 64位整型 (-9223372036854775808 到 9223372036854775807)
float32和float64 范围分别为3.4e38和1.8e308<br>
complex64和complex128<br>
<strong>字符类型</strong>
uint8类型，或者叫 byte 型，代表一个ASCII码字符。<br>
rune类型，代表一个 UTF-8字符。
<code>rune</code> 类型是 <code>int32</code> 的别名，用于表示一个Unicode码点（Unicode code point）。每个<code>rune</code>对应一个Unicode字符，可以表示任何语言的字符（包括中文、表情符号等）
Go的字符串默认以UTF-8编码存储。当遍历字符串时，若用 <code>for range</code>，会自动按 <code>rune</code> 为单位迭代，而非字节：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;Hello 世界&#34;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1">// r 的类型是 rune</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%c &#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1">// 输出: H e l l o 世 界</span>
</span></span></code></pre></div><p>这里是对于range的解释：<a href="https://www.cnblogs.com/Julypassed/p/18160280">golang中使用for range 遍历字符串时常遇到的bug，byte和rune类型，源码分析 - Harven - 博客园</a></p>
<h4 id="数组和切片">数组和切片<a hidden class="anchor" aria-hidden="true" href="#数组和切片">#</a></h4>
<p>数组（Array）和切片（Slice）的区别其实是数组在定义的时候已经规定好了长度，而切片并没有规定长度
数组是需要指定初始化长度（或者叫做容量）的序列，在定义时可以直接设置初始值，如果不设置，初始值为默认值
切片是一个拥有相同类型元素的可变长度的序列，可以通过append函数添加元素</p>
<ol>
<li>两者的对比
![[Pasted image 20240809083724.png]]</li>
<li>代码书写
切片可以用内置函数 <code>make</code> 来创建，这也是你创建动态数组的方式。
<code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1">// len(a)=5</span>
</span></span></code></pre></div><p>要指定它的容量，需向 <code>make</code> 传入第三个参数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="c1">//创建一个数组</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="c1">//创建一个子切片,[0:3)左闭右开</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nx">s2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">//创建一个切片，长度为3，初始元素为0，容量为4</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="nx">s1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">//追加一个元素</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nx">s2</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">//追加一个元素</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1">//切片比较好的创建方式为make([]int,0,cap)</span>
</span></span></code></pre></div><ol start="3">
<li>子切片
通过[start:end]来获得子切片，arr[start:end]获取的是<code>[start,end)</code>之间的元素，左闭右开
arr[:end]获得<code>[0,end)</code>之间的元素
arr[start:]获得<code>[start,len(arr))</code>之间的元素
子切片与原切片共享底层数组</li>
<li>理解slice
实际上是Go中特殊的ArrayList，但是没有插入和删除的操作，只有append操作，下面稍微写了一下对于slice的insert和delete，在这其中使用了copy函数：当我们在Go语言中需要将一个切片的内容复制到另一个切片时，可以使用内置的copy()函数，copy()函数用于将源切片中的元素复制到目标切片中。
slice的零值是nil，通过[]int这种方式来创建切片时首先会创建一个对应的底层数组</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">//实现指定位置插入元素</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kd">func</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">value</span> <span class="kt">int</span><span class="p">,</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//扩展一个空间</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="p">:])</span> <span class="c1">//向后移动</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span> <span class="c1">//插入元素</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">return</span> <span class="nx">slice</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">//实现指定位置删除元素</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kd">func</span> <span class="nb">delete</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="p">:],</span><span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span> <span class="c1">//向前移动</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">return</span> <span class="nx">slice</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">//删除最后一个元素</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>练习切片的一个小程序，通过灰度图展示公式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="s">&#34;golang.org/x/tour/pic&#34;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kd">func</span> <span class="nf">Pic</span><span class="p">(</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">uint8</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="nx">ans</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">uint</span><span class="p">,</span><span class="nx">dy</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="k">for</span> <span class="nx">y</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">y</span><span class="p">&lt;</span><span class="nx">dy</span><span class="p">;</span><span class="nx">y</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">		<span class="nx">row</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint8</span><span class="p">,</span><span class="nx">dx</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">		<span class="k">for</span> <span class="nx">x</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">x</span><span class="p">&lt;</span><span class="nx">dx</span><span class="p">;</span><span class="nx">x</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">			<span class="nx">row</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="p">(</span><span class="nx">y</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">		<span class="nx">ans</span><span class="p">[</span><span class="nx">y</span><span class="p">]=</span><span class="nx">row</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">	<span class="nx">pic</span><span class="p">.</span><span class="nf">Show</span><span class="p">(</span><span class="nx">Pic</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="字符串">字符串<a hidden class="anchor" aria-hidden="true" href="#字符串">#</a></h4>
<p>字符串用<code>&quot;abc&quot;</code>表示，单个字符用<code>'a'</code>表示
字符串可以通过索引访问字符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">s</span><span class="o">:=</span><span class="s">&#34;abcde&#34;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span></code></pre></div><p>字符串可以通过切片访问连续字符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">s</span><span class="o">:=</span><span class="s">&#34;abcde&#34;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
</span></span></code></pre></div><p>统计字符串的个数要用特殊的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">s</span><span class="o">:=</span><span class="s">&#34;abcde&#34;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">s</span><span class="p">))}</span>
</span></span></code></pre></div><p>将字符编码转换为字符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">s</span><span class="o">:=</span><span class="s">&#34;abcde&#34;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span></code></pre></div><p>遍历字符串的每一个字符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">s</span><span class="o">:=</span><span class="s">&#34;我爱你中国&#34;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nx">cs</span><span class="o">:=</span><span class="p">[]</span><span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nx">for_</span><span class="p">,</span><span class="nx">ch</span><span class="o">:=</span><span class="k">range</span> <span class="nx">cs</span><span class="p">{</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>使用buffer累加字符串</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">var</span> <span class="nx">bf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">bf</span><span class="p">,</span><span class="s">&#34;a%d&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nx">s</span><span class="o">:=</span><span class="nx">bf</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> 
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> 
</span></span></code></pre></div><h4 id="指针">指针<a hidden class="anchor" aria-hidden="true" href="#指针">#</a></h4>
<ul>
<li><code>&amp;</code>符号会【生成】一个指向其作用对象的指针。</li>
<li><code>*</code>符号表示指针指向的【底层的值】</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">2701</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">i</span>         <span class="c1">// p为i的指针</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 通过指针显示的是i的值</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">21</span>         <span class="c1">// 通过指针修改的是i的值</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">j</span>         <span class="c1">// 将p改为j的指针</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="o">*</span><span class="nx">p</span> <span class="o">/</span> <span class="mi">37</span>   <span class="c1">// 通过指针操作的是j的值，除以37的结果重新通过指针赋给j</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="结构体定义">结构体定义<a hidden class="anchor" aria-hidden="true" href="#结构体定义">#</a></h4>
<h5 id="定义类型">定义类型<a hidden class="anchor" aria-hidden="true" href="#定义类型">#</a></h5>
<p>定义类型的不同方式，使用也不相同</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// BigServer type A=B</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kd">type</span> <span class="nx">BigServer</span> <span class="p">=</span> <span class="nx">server</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1">// SmellServer type A B</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kd">type</span> <span class="nx">SmellServer</span> <span class="nx">server</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="nx">service1</span> <span class="o">:=</span> <span class="nx">SmellServer</span><span class="p">{}</span>  
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="nx">service2</span> <span class="o">:=</span> <span class="nx">BigServer</span><span class="p">{}</span>  
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="nf">server</span><span class="p">(</span><span class="nx">service1</span><span class="p">).</span><span class="nf">open</span><span class="p">()</span>  
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="nx">service2</span><span class="p">.</span><span class="nf">open</span><span class="p">()</span>
</span></span></code></pre></div><h5 id="初始化">初始化<a hidden class="anchor" aria-hidden="true" href="#初始化">#</a></h5>
<p>Go没有构造函数，所以new直接分配内存然后把内存都置0</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">man1</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;李四&#34;</span><span class="p">}</span>  
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nx">man1</span><span class="p">.</span><span class="nf">Walk</span><span class="p">(</span><span class="nx">man1</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nx">man2</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Person</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="nx">man2</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;王五&#34;</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nx">man2</span><span class="p">.</span><span class="nf">Walk</span><span class="p">(</span><span class="nx">man2</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</span></span></code></pre></div><h5 id="方法接收器">方法接收器<a hidden class="anchor" aria-hidden="true" href="#方法接收器">#</a></h5>
<p>用于定义结构体对应的方法（也可以为非结构体类型声明方法）
只能为在同一个包中定义的接收者类型声明方法，而不能为其它别的包中定义的类型（包括 <code>int</code> 之类的内置类型）声明方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// 结构体接收器  </span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">ChangeName</span><span class="p">(</span><span class="nx">newName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">   <span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">newName</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1">// 指针接收器  </span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="nf">ChangeAge</span><span class="p">(</span><span class="nx">newAge</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">   <span class="nx">p</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="nx">newAge</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// 结构体接收器，内容不会改变  </span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="nx">man1</span><span class="p">.</span><span class="nf">ChangeName</span><span class="p">(</span><span class="s">&#34;赵六&#34;</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// 指针接收器，内容会改变，我直接遇事不决用指针</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="nx">man1</span><span class="p">.</span><span class="nf">ChangeAge</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">man1</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="链表">链表<a hidden class="anchor" aria-hidden="true" href="#链表">#</a></h4>
<h4 id="哈希表">哈希表<a hidden class="anchor" aria-hidden="true" href="#哈希表">#</a></h4>
<p>[[哈希表（Hash-Table）]]
![[哈希表（Hash-Table）#Go中如何使用HashTable]]</p>
<p>Go之旅中的一个练习，用的是比较简单的map，实现 <code>WordCount</code>。它应当返回一个映射，其中包含字符串 <code>s</code> 中每个“单词”的个数。 函数 <code>wc.Test</code> 会为此函数执行一系列测试用例，并输出成功还是失败</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="s">&#34;golang.org/x/tour/wc&#34;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kd">func</span> <span class="nf">WordCount</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">//Field函数直接分割</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="nx">x</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">		<span class="nx">x</span><span class="p">[</span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">	<span class="nx">wc</span><span class="p">.</span><span class="nf">Test</span><span class="p">(</span><span class="nx">WordCount</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="控制结构">控制结构<a hidden class="anchor" aria-hidden="true" href="#控制结构">#</a></h4>
<p>for 类似 while 的无限循环
fori 一般的按照下标循环
forr 最为特殊的 range 遍历，可以用于map遍历</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34; index = %d,number = %d \n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34; index = %d,number = %d \n&#34;</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>if-else：没什么可以记录的，跟其他的语言一样的</p>
<h3 id="函数调用">函数调用<a hidden class="anchor" aria-hidden="true" href="#函数调用">#</a></h3>
<p>Go 语言选择了传值的方式，<strong>无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong></p>
<pre tabindex="0"><code>无需声明原型
支持不定变参
支持多返回值
支持命名返回参数
函数也是一种类型，一个函数可以复制给变量；可以作为参数传递给其他函数
不支持嵌套（一个包不能有重名的函数）
不支持重载
不支持默认参数
</code></pre><h4 id="整数与数组类型">整数与数组类型<a hidden class="anchor" aria-hidden="true" href="#整数与数组类型">#</a></h4>
<p>如下所示的函数 <code>myFunction</code> 接收了两个参数，整型变量 <code>i</code> 和数组 <code>arr</code>，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 <code>myFunction</code> 函数调用前后分别打印两个参数的地址，最后的结果main函数中的参数地址与myFunction中的地址完全不同，所以能够证明<strong>Go 语言的整型和数组类型都是值传递的</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kd">func</span> <span class="nf">myFunction1</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">30</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;before calling - i=(%d, %p) arr=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="nf">myFunction1</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;after  calling - i=(%d, %p) arr=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="结构体与指针类型">结构体与指针类型<a hidden class="anchor" aria-hidden="true" href="#结构体与指针类型">#</a></h4>
<ul>
<li>传递结构体时：会拷贝结构体中的全部内容</li>
<li>传递结构体指针时：会拷贝结构体指针</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kd">func</span> <span class="nf">myFunction2</span><span class="p">(</span><span class="nx">a</span> <span class="nx">MyStruct</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">MyStruct</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="nx">a</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">31</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="nx">b</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">41</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;in my_function - a=(%d, %p) b=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="nx">MyStruct</span><span class="p">{</span><span class="nx">i</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MyStruct</span><span class="p">{</span><span class="nx">i</span><span class="p">:</span> <span class="mi">40</span><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;before calling - a=(%d, %p) b=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="nf">myFunction2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;after calling  - a=(%d, %p) b=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="方法与函数">方法与函数<a hidden class="anchor" aria-hidden="true" href="#方法与函数">#</a></h4>
<ul>
<li><strong>方法</strong> (<code>func (c *Context) String</code>)：
<ul>
<li>方法的第一个参数是一个接收者（receiver），即 <code>c *Context</code>，表示该方法属于 <code>Context</code> 类型。</li>
<li>方法的调用方式是通过类型的实例来调用，例如 <code>context.String(...)</code>，其中 <code>context</code> 是 <code>Context</code> 类型的一个实例。</li>
<li>表达的是 <code>String</code> 操作是 <code>Context</code> 类型的一部分，是 <code>Context</code> 对象的一个行为。</li>
<li>更适合表示“某种类型的实例应该具备的行为”。</li>
</ul>
</li>
<li><strong>函数</strong> (<code>func String(c *Context)</code>)：
<ul>
<li>一个普通的函数，它的参数是 <code>c *Context</code>，表示函数接收一个 <code>*Context</code> 类型的参数。</li>
<li>函数的调用方式是直接调用，并传入参数，例如 <code>String(context, ...)</code>，参数列表名称在前，类型在后，可以有多返回值，返回值也可以有名称</li>
<li>是独立于 <code>Context</code> 类型的一个函数，只是恰好接受一个 <code>Context</code> 类型的参数。</li>
<li>更适合表示“一般性的操作或工具函数”，而不是某种类型的固有行为。</li>
</ul>
</li>
</ul>
<h5 id="方法与指针重定向">方法与指针重定向<a hidden class="anchor" aria-hidden="true" href="#方法与指针重定向">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nf">Scale</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">*</span> <span class="nx">f</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*</span> <span class="nx">f</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="kd">func</span> <span class="nf">ScaleFunc</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">,</span> <span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">	<span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">*</span> <span class="nx">f</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">	<span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*</span> <span class="nx">f</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">var</span> <span class="nx">v</span> <span class="nx">Vertex</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nf">ScaleFunc</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1">// 编译错误！</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nf">ScaleFunc</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// OK</span>
</span></span></code></pre></div><p>而接收者为指针的的方法被调用时，接收者既能是值又能是指针：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">var</span> <span class="nx">v</span> <span class="nx">Vertex</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Vertex</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nf">Scale</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">//OK</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">).</span><span class="nf">Scale</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1">//OK</span>
</span></span></code></pre></div><p>对于语句 <code>v.Scale(5)</code> 来说，即便 <code>v</code> 是一个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。
反之同理，接受一个值作为参数的函数必须接受一个指定类型的值，而以值为接收者的方法被调用时，接收者既能为值又能为指针，这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>，<strong>其实就是遇到不同情况自动转换</strong>。</p>
<h4 id="接口">接口<a hidden class="anchor" aria-hidden="true" href="#接口">#</a></h4>
<p><strong>接口</strong>是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息。如下图所示，接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。
<img loading="lazy" src="https://img.draveness.me/golang-interface.png" alt="golang-interface"  />
</p>
<p>在 Java 中：实现接口需要显式地声明接口并实现所有方法，在接口中不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">MyInterface</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Hello&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sayHello</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyInterfaceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">MyInterface</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sayHello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">MyInterface</span><span class="p">.</span><span class="na">hello</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>在 Go 中：实现接口的所有方法就隐式地实现了接口，但是在接口中我们只能定义方法签名，不能包含成员变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">	<span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kd">type</span> <span class="nx">RPCError</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="nx">Code</span>    <span class="kt">int64</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="nx">Message</span> <span class="kt">string</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">RPCError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s, code=%d&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Message</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Code</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Java中的类必须显式地声明实现的接口，与Java不同的是Go语言中<strong>接口的实现都是隐式的</strong>，我们只需要实现 <code>Error() string</code> 方法就实现了 <code>error</code> 接口</p>
<h5 id="接口方法">接口方法<a hidden class="anchor" aria-hidden="true" href="#接口方法">#</a></h5>
<p>接口就是规定了一个<strong>需要实现的方法列表</strong>，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口
我们定义的 <code>Singer</code> 接口类型，它包含一个 <code>Sing</code> 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">type</span> <span class="nx">Singer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="nf">Sing</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后有一个 <code>Bird</code> 结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">type</span> <span class="nx">Bird</span> <span class="kd">struct</span> <span class="p">{}</span>
</span></span></code></pre></div><p>因为 <code>Singer</code> 接口只包含一个 <code>Sing</code> 方法，所以只需要给 <code>Bird</code> 结构体添加一个 <code>Sing</code> 方法就可以满足 <code>Singer</code> 接口的要求。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// Sing Bird类型的Sing方法</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">Bird</span><span class="p">)</span> <span class="nf">Sing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;汪汪汪&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>为什么要用接口呢，因为有时不止一个类型需要实现这个方法，可能有多个结构体需要 <code>Sing()</code> 这个方法，这时就可以使用接口类型，把所有会叫的动物当成 <code>Singer</code> 类型来处理</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kd">type</span> <span class="nx">Sayer</span> <span class="kd">interface</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="nf">Say</span><span class="p">()</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span><span class="p">{}</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">)</span> <span class="nf">Say</span><span class="p">()</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;cat miao&#34;</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">Say</span><span class="p">()</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dog woof&#34;</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="kd">func</span> <span class="nf">Hungry</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Sayer</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="nx">s</span><span class="p">.</span><span class="nf">Say</span><span class="p">()</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="kd">var</span> <span class="nx">c</span> <span class="nx">Cat</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="kd">var</span> <span class="nx">d</span> <span class="nx">Dog</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="nf">Hungry</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="nf">Hungry</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Stringer是 <code>fmt</code> 包中定义的 <code>Stringer</code> 是最普遍的接口之一，是一个可以用字符串描述自己的类型，任何实现了 <code>String() string</code> 方法的类型都隐式满足该接口。<code>fmt</code> 包（还有很多包）都通过此接口来打印值，可以规范化对应值的输出</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kd">type</span> <span class="nx">IPAddr</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// TODO: 为 IPAddr 添加一个 &#34;String() string&#34; 方法。</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">I</span> <span class="nx">IPAddr</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%v.%v.%v.%v&#34;</span><span class="p">,</span><span class="nx">I</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nx">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nx">I</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="nx">I</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="nx">hosts</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">IPAddr</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">		<span class="s">&#34;loopback&#34;</span><span class="p">:</span>  <span class="p">{</span><span class="mi">127</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">		<span class="s">&#34;googleDNS&#34;</span><span class="p">:</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">ip</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">hosts</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v: %v\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">ip</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>类似的还有，sort接口，json序列化，io读写，以及http的请求处理
rot13Reader的实现，一个接口组合的实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="s">&#34;io&#34;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kd">type</span> <span class="nx">rot13Reader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="kd">func</span> <span class="nf">rot13</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	<span class="k">case</span> <span class="nx">c</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">		<span class="k">return</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">c</span><span class="o">-</span><span class="sc">&#39;A&#39;</span><span class="o">+</span><span class="mi">13</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">	<span class="k">case</span> <span class="nx">c</span> <span class="o">&gt;=</span> <span class="sc">&#39;a&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">		<span class="k">return</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">c</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="mi">13</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">		<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">rot13Reader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">	<span class="c1">// 要调用底层的Read</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">rot13</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="s">&#34;Lbh penpxrq gur pbqr!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">rot13Reader</span><span class="p">{</span><span class="nx">s</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">	<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>图像生成器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="s">&#34;golang.org/x/tour/pic&#34;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="s">&#34;image&#34;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="s">&#34;image/color&#34;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kd">type</span> <span class="nx">Image</span> <span class="kd">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nx">Width</span> <span class="kt">int</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="nx">Height</span> <span class="kt">int</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1">// Bounds image.Rectangle</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">img</span> <span class="nx">Image</span><span class="p">)</span><span class="nf">Bounds</span><span class="p">()</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Rectangle</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="k">return</span> <span class="nx">image</span><span class="p">.</span><span class="nf">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">img</span><span class="p">.</span><span class="nx">Width</span><span class="p">,</span><span class="nx">img</span><span class="p">.</span><span class="nx">Height</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1">// Color color.RGBModel</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">img</span> <span class="nx">Image</span><span class="p">)</span> <span class="nf">ColorModel</span><span class="p">()</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Model</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">	<span class="k">return</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBAModel</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1">// At  color.Color</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">img</span> <span class="nx">Image</span><span class="p">)</span> <span class="nf">At</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Color</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">x</span><span class="p">^</span><span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">	<span class="k">return</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="nx">v</span><span class="p">,</span><span class="nx">v</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">Image</span><span class="p">{</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">	<span class="nx">pic</span><span class="p">.</span><span class="nf">ShowImage</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="错误error">错误（error）<a hidden class="anchor" aria-hidden="true" href="#错误error">#</a></h4>
<p>Go 程序使用 <code>error</code> 值来表示错误状态。通常函数会返回一个 <code>error</code> 值，调用它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="s">&#34;math&#34;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kd">type</span> <span class="nx">ErrNegativeSqrt</span> <span class="kd">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="nx">Value</span> <span class="kt">float64</span>		
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kd">func</span> <span class="nf">Sqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="k">if</span> <span class="nx">x</span><span class="p">&lt;</span><span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">		<span class="k">return</span> <span class="nx">x</span> <span class="p">,</span> <span class="nx">ErrNegativeSqrt</span><span class="p">{</span><span class="nx">Value</span><span class="p">:</span> <span class="nx">x</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">		<span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span><span class="kc">nil</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1">// 重写Error方法，输出更多错误提示信息</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">ErrNegativeSqrt</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;cannot Sqrt negative number: %v&#34;</span><span class="p">,</span><span class="nb">float64</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="接口值">接口值<a hidden class="anchor" aria-hidden="true" href="#接口值">#</a></h5>
<p>接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。也就是说接口值由“类型”和“值”组成。
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/mariosight/image/picture/interface01.png" alt="interface01.png"  />
</p>
<p><strong>接口值（Interface Value）</strong> 本质上是一个动态容器，它可以持有任意具体类型的值，并在运行时记录类型信息，隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，<strong>无需提前准备</strong></p>
<p><code>nil</code> 接口值既不保存值也不保存类型，为 <code>nil</code> 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个<strong>具体</strong>方法的类型
指定了零个方法的接口值被称为<strong>空接口</strong>，空接口可保存任何类型的值，空接口被用来处理未知类型的值</p>
<h6 id="类型断言">类型断言<a hidden class="anchor" aria-hidden="true" href="#类型断言">#</a></h6>
<p><strong>类型断言</strong>是一种可以从接口值中提取其动态类型具体值的方法，<strong>给一个什么值，他就变成对应的类型</strong>
该语句断言接口值 <code>i</code> 保存了具体类型 <code>Type</code>，并将其底层类型为 <code>Type</code> 的值赋予变量 <code>t</code>，如果未保存，那么该语句就会触发panic</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>
</span></span></code></pre></div><p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl">	<span class="nx">t</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>
</span></span></code></pre></div><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>
否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生 panic</p>
<h6 id="类型选择">类型选择<a hidden class="anchor" aria-hidden="true" href="#类型选择">#</a></h6>
<p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构，它们针对给定接口值所存储的值的类型进行比较</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kd">func</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">switch</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">case</span> <span class="nx">Circle</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;圆形，半径: %v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Radius</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">case</span> <span class="nx">Rectangle</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;矩形，长: %v, 宽: %v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Width</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Height</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;未知形状&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="nf">Describe</span><span class="p">(</span><span class="nx">Circle</span><span class="p">{</span><span class="nx">Radius</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>    <span class="c1">// 输出：圆形，半径: 3</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="nf">Describe</span><span class="p">(</span><span class="nx">Rectangle</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">})</span>      <span class="c1">// 输出：矩形，长: 4, 宽: 5</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="闭包closure">闭包（closure）<a hidden class="anchor" aria-hidden="true" href="#闭包closure">#</a></h4>
<p>闭包（closure）是指<strong>一个函数可以捕获并引用其外部作用域中的变量</strong>，即使在这些变量的作用域已经结束之后，换句话说，<strong>该函数被“绑定”到了这些变量</strong>。闭包的实现依赖于函数本身以及它所引用的环境</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">i</span> <span class="o">:=</span> <span class="mi">13</span>  
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;i = &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nf">a</span><span class="p">()</span>
</span></span></code></pre></div><p><strong>延迟绑定</strong>：闭包捕获的是变量的引用，而不是它在循环中每次迭代的值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kd">func</span> <span class="nf">Delay</span><span class="p">()</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="nx">fns</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">func</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">       <span class="nx">fns</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">fns</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">          <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;i = &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">       <span class="p">})</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">//执行的时候i = 10，因为闭包捕获的是变量i的引用,而不是值  </span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">//因此在循环中使用闭包时需要小心处理  </span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">//？？为什么我这里是i从0-9，好诡异啊</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fns</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">       <span class="nf">fn</span><span class="p">()</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="杂项记录">杂项记录<a hidden class="anchor" aria-hidden="true" href="#杂项记录">#</a></h3>
<h4 id="查看对应变量的类型">查看对应变量的类型<a hidden class="anchor" aria-hidden="true" href="#查看对应变量的类型">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">//使用%T</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type: %T&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">//使用reflect下的Typeof，要引入reflect包</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">Typeof</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
</span></span></code></pre></div><h4 id="输出其命令行参数">输出其命令行参数<a hidden class="anchor" aria-hidden="true" href="#输出其命令行参数">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">package</span> <span class="nx">main</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="p">(</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="s">&#34;fmt&#34;</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="s">&#34;os&#34;</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">)</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kd">var</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="p">{</span> <span class="c1">//输出目标文件命令的名字</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="nx">s</span> <span class="o">+=</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">arg</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="nx">sep</span> <span class="p">=</span> <span class="s">&#34; &#34;</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1">//for i := 1; i &lt; len(os.Args); i++ {  </span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1">// s += sep + os.Args[i]  </span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1">// sep = &#34; &#34;  </span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1">//} </span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="ok的使用">OK的使用<a hidden class="anchor" aria-hidden="true" href="#ok的使用">#</a></h4>
<p>在 Go 语言中，<code>ok</code> 通常与 <code>map</code> 结合使用，用于<strong>判断某个键（key）是否存在于 map 中</strong>，是 Go 中一种常见的“安全读取”模式。
通过第二个返回值 <code>ok</code>（布尔类型）可以判断键是否存在：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl">    <span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;apple&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&#34;banana&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="c1">// 检查键是否存在</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="s">&#34;apple&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;apple 存在，值是&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;apple 不存在&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>在练习LeetCode的时候也看到有高级的语句记录了下来，对于ok在if中的使用含义，经常在map中使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">func</span> <span class="nf">learnErrorHandling</span><span class="p">()</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1">// &#34;, ok&#34;用来判断有没有正常工作  </span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="s">&#34;three&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s">&#34;four&#34;</span><span class="p">}</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="c1">// ok 为false，因为m中没有1  </span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;no one there&#34;</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 如果x在map中的话，x就是那个值喽。  </span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>[!note]
上述代码中，在if语句中，<strong>ok</strong>这个bool变量的含义是，如果其中有<strong>1</strong>这个key，那么其value赋值给<strong>x</strong>然后令ok为true，如果没有则令ok为false</p></blockquote>
<h4 id="引用包时出错">引用包时出错<a hidden class="anchor" aria-hidden="true" href="#引用包时出错">#</a></h4>
<p>包在之后的代码中并未引用，可以通过在包名前加<code>_</code>进行匿名引用</p>
<h4 id="定义变量">定义变量<a hidden class="anchor" aria-hidden="true" href="#定义变量">#</a></h4>
<p>var后面定义有默认类型，如果不想按照默认类型来的话，就需要自己写
go是强类型语言，不做任何类型转换
或者直接:=进行赋值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">var</span> <span class="nx">a</span>  <span class="p">=</span> <span class="mi">13</span> <span class="c1">// 默认为int</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kd">var</span> <span class="nx">b</span> <span class="kt">uint</span> <span class="p">=</span><span class="mi">15</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="mi">13</span>
</span></span></code></pre></div><h4 id="求string的长度">求string的长度<a hidden class="anchor" aria-hidden="true" href="#求string的长度">#</a></h4>
<p>len()函数求出来的是<strong>字节的长度</strong>，而不是字符长度
应该用<code>utf8.RuneCountInString(&quot;你好&quot;)</code>进行求解</p>
<h4 id="对二维数组进行排序">对二维数组进行排序<a hidden class="anchor" aria-hidden="true" href="#对二维数组进行排序">#</a></h4>
<p>这里的 <code>slices.SortFunc</code> 通过传入一个比较函数（<code>func(p, q []int) int</code>）来实现对 <code>intervals</code> 进行排序
<strong>比较函数</strong>：<code>func(p, q []int) int</code>。它对两个元素 <code>p</code> 和 <code>q</code> 进行比较。</p>
<ul>
<li>如果返回值 <code>&lt; 0</code>，表示 <code>p</code> 应排在 <code>q</code> 之前。</li>
<li>如果返回值 <code>&gt; 0</code>，表示 <code>q</code> 应排在 <code>p</code> 之前。</li>
<li>如果返回值 <code>= 0</code>，表示 <code>p</code> 和 <code>q</code> 的顺序无所谓。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">slices</span><span class="p">.</span><span class="nf">SortFunc</span><span class="p">(</span><span class="nx">intervals</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">})</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mariosight.github.io/tags/golang/">Golang</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mariosight.github.io/posts/ndnsim%E4%BB%BF%E7%9C%9F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/">
    <span class="title">« 上一页</span>
    <br>
    <span>ndnSIM仿真安装以及使用</span>
  </a>
  <a class="next" href="https://mariosight.github.io/posts/ubuntu22.04%E4%B8%8Bcharm%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
    <span class="title">下一页 »</span>
    <br>
    <span>Ubuntu22.04LTS 下Python3.7.9&#43;Charm-Crypto&#43;pypbc&#43;Jupyter环境搭建</span>
  </a>
</nav>

  </footer><div id="tw-comment"></div>
<script>
    
    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";
    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
            }
        }
        sendMessage({ setConfig: { theme: getStoredTheme() } })
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "mariosight\/mariosight.github.io",
            "data-repo-id": "R_kgDOM6YERg",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDOM6YERs4CjA-3",
            "data-mapping": "pathname",
            "data-strict": "0",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "zh-CN",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
            ([key, value]) => giscusScript.setAttribute(key, value));
        document.querySelector("#tw-comment").appendChild(giscusScript);

        
        const themeSwitcher = document.querySelector("#theme-toggle");
        if (themeSwitcher) {
            themeSwitcher.addEventListener("click", setGiscusTheme);
        }
        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");
        if (themeFloatSwitcher) {
            themeFloatSwitcher.addEventListener("click", setGiscusTheme);
        }
    });
</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://mariosight.github.io">©2024 Mario&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
